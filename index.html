Напиши html комментарий с текстом Комментарий отвечает на вопрос "ЗАЧЕМ НАПИСАНА ЭТА ЧАСТЬ КОДА".
<!-- Комментарий отвечает на вопрос "ЗАЧЕМ НАПИСАНА ЭТА ЧАСТЬ КОДА" . -->

Открывающий тег или одиночный тег могут содержать обязательные и необязательные атрибуты.

синтаксис тега

Для тега img есть два обязательных атрибута - src и alt. img - это особый тег, который называется замещаемым строчным.
Аналогов мало (video, object). Браузер сперва загружает html и отображает текст из alt, а затем загружает изображение и
замещает этим изображением текст. Если загрузка изображения не удалась, то текст остается на странице.

Размер текста как правило меньше изображения и поэтому в помощь браузеру можно задать необязательные атрибуты width и
height с размерами изображения,
которые мы хотим увидеть на экране. Реальное изображение может быть больше или меньше - браузер подгонит размер под
заданный. Если не задать размер, браузер вставит изображение с тем размером, которое на самом деле есть у изображения.

Внимание
Атрибуты width и height должны иметь значения в виде числа без px.

Задание
Напиши в теге img два обязательных и два необязательных атрибута.

Список атрибутов:

src: файл, расположенный по относительному пути photo.jpg;
alt: текст с описанием изображения Изображение примера;
width: ширина в 200 пикселей;
height: height в 150 пикселей.
<img src="photo.jpg" alt="Изображение примера" width="200" height="150">

<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li>JavaScript</li>
</ul>
Вложенность тегов.
Большинство тегов по умолчанию имеют поведение, по которому их можно разделить на две группы - строчные и блочные.

Универсальный блочный контейнер - div.

Универсальный строчный контейнер - span.

К основным свойствам блочных элементов отностяся:

ширина определяется шириной родителя;
ширину и высоту можно задавать;
перед и после элемента есть знаки переноса строки;
К основным свойствам строчных элементов отностяся:

ширина определяется шириной контента;
ширину и высоту нельзя задавать;
переноса на новую строку происходит только после заполнения ширины родительского элемента;
Задание
Оберни строчные теги button контейнером div с классом buttons так, чтобы в двух рядах было по три кнопки и каждый ряд
начинался с новой строки.

Порядок элементов button должен быть сохранен.
<div class="buttons">
<button type="button" class="button">inline</button>
<button type="button" class="button">block</button>
<button type="button" class="button">inline-block</button></div>
<div class="buttons">
<button type="button" class="button">HTML</button>
<button type="button" class="button">CSS</button>
<button type="button" class="button">JavaScript</button>
</div>

Вложенность тегов.
Ссылка.
Ссылка имеет особое свойство - она "прозрачна" по отношению к свойству block или inline своих потомков.

Поэтому в зависимости от того, какой элемент оборачивает ссылка ее поведение меняется.

Т.е. ссылка может вести себя как блочный элемент, если она обернула div или li. А может вести себя как строчный элемент,
если она обернула span или img.

Задание
Оберни контент ссылки - строку Текст строчным тегом span для одной ссылки и блочным тегом p для второй ссылки.

Визуально убедись, что к каждой из ссылок применилось свойство inline или block.

Порядок элементов a должен быть сохранен.

<div class='box'>
    <a href="#" class='link-inline'><span>Текст</span></a>
    без переноса на новую строку
</div>
<div class='box'>
    <a href="#" class='link-block'><p>Текст</p></a>
    с переносом на новую строку
</div>

Исправьте порядок нумерации удалив атрибут тега ol.
Расставь элементы li в нужном порядке согласно описанию последовательности загрузки Номер 1 
должен соответствовать
первому файлу, который будет загружен. Номер 2 - второму, номер 3 - третьему.

<div class="card">
    <h4 class="card-title">Порядок загрузки файлов браузером</h4>
    <ol class="card-items">
        <li class="card-item">Файл html</li>
        <li class="card-item">Ссылки на файлы внутри тега head</li>
        <li class="card-item">Ссылки на файлы внутри body</li>
    </ol>
</div>
Группировка однородных наборов тегов.
Два правила о том как собирать теги в группу:

Если некоторый набор тегов повторяется и служит для отображения одной темы, то такой набор следует обернуть тегом.
Если после оборачивания набора тегов образовался новый набор повторяющихся тегов (общая тема - определенный набор тем
или определенное оформление), то см. правило 1.
Задание
Сгруппируй наборы тегов с помощью списка ul и элементов li.
Тег ul должен иметь класс со значением (существительное во множественном числе) cards.
Тег li должен иметь класс со значением (существительное в единственном числе) card.

<ul class="cards">
<li class="card">
    <h4 class="card-title">Карточка о теме 1</h4>
<div class="wrp-img">
    <img class="card-image" src="photo.jpg" alt="описание фото">
</div>
<p class="card-description">Подробное описание темы 1</p></li>

<li class="card">
    <h4 class="card-title">Карточка о теме 2</h4>
<div class="wrp-img">
    <img class="card-image" src="photo2.jpg" alt="описание фото">
</div>
<p class="card-description">Подробное описание темы 2</p>
</li>

<li class="card">
<h4 class="card-title">Карточка о теме 3</h4>
<div class="wrp-img">
    <img class="card-image" src="photo3.jpg" alt="описание фото">
</div>
<p class="card-description">Подробное описание темы 3</p></li>
</ul>

Ссылка на внешний ресурс в новом окне браузера. Атрибуты target и rel
Задание
Ссылка должна открыться в новой вкладке. В целях безопасности надо разорвать связь между новой вкладкой и той вкладкой,
где расположена ссылка.

Для этого добавь ссылке необходимые значения атрибутов target и rel.
<a href="https://goit.com.ua" target="_blank" rel="noopener noreferrer">
    GoIT
</a>
Ссылка на скачиваемый файл. Атрибут download
Задание
Добавь ссылке атрибут, необходимый для скачивания файла

<a href="resume.pdf" download="">Резюме</a>

Ссылка для телефона и email. Специальные значения href
Задание
Добавь ссылкам специальные значения href.

<!-- Ссылка на телефонный номер -->
<a href="tel:+14251234563">+1 (425) 123-45-63</a>
<!-- Ссылка на адрес электронной почты  -->
<a href="mailto:example@gmail.com">example@gmail.com</a>

Ссылка-якорь
Задание
Расставь значения атрибутов id для навигации по странице с помощью ссылок из aside.
<header id="top">
    <!-- контент из logo, nav, поиска  -->
</header>
<main>
    <aside>
        <ul>
            <li><a href="#top">Вверх страницы</a></li>
            <li><a href="#page-theme">К основной теме</a></li>
            <li><a href="#bottom">Вниз страницы</a></li>
        </ul>
    </aside>
    <article id="page-theme">
        <!-- основная тема страницы  -->
    </article>
</main>
<footer id="bottom">
    <!-- контент из logo, nav, контактов, копирайта  -->
</footer>

Изображение с подписью. Элементы figure и figcaption.
Задание
Размести теги внутри тега figure и контент внутри тега figcaption.

<figure>
<img src="photo.jpg" alt="описание фото" />
<figcaption>
Внутри ссылки допускается размещение только одного 
элемента img, любого количества текста или элементов. 
Запрещается размещать интерактивные элементы.</figcaption>
</figure>

Размещение только одного тега img внутри ссылки.
Внутри ссылки допускается размещение только одного тега img.

Внимание
Внутри ссылки допускается размещение любого числа svg элементов. Но использование svg будет рассмотрено позднее - в
следующих темах.

Задание
Два изображения должны быть ссылкой на одну и ту же страницу. Разместите теги правильно. Допускается добавление только
одного элемента - еще одной ссылки.
<a href="./about"><img src="photo.jpg" alt="запись в ноутбуке" /></a>
<a href="./about">
<img src="photo2.jpg" alt="запись на бумаге" /></a>

index.html - точка входа в приложение
Большинство web серверов настроен так, что при обращении по имени сайта (например my.github.io), сервер ищет файл с
названием index.html Если такой файл не будет найден, то отобразится ошибка 404 - страница на найдена.

Для обращения к любому другому файлу - например about.html, требуется явно указать название файла:
my.github.io/about.html

Задание
Текст в комментарии содержит описание структуры файлов и папок (директорий) для размещения на github.

Чтобы проект отобразился как веб-страница веб-сервер github должен найти файл index.html и выполнить его. Т.е. нужен
файл в которого произойдет запуск приложения (точка входа в приложение).

Замени название файла hw.html, чтобы приложение начало выполняться с чтения именно этого файла.

<!--  TODO 
* создать проект со структурой:
images/logo.svg
css/style.css
about.html
index.html
 -->

Относительный путь. '../' - подъем из папки (директории).
Есть структура файлов и папок (директорий) для размещения на github (т.е. на ОС Linux)

images/logo.png
pages/about.html
index.html
Задание
Файл about.html расположен в директории pages относительно файла index.html. Напиши для этого файла

путь для ссылки на файл index.html из файла about.html,
путь для изображения на файл logo.png,

<!-- файл about.html -->
<a href="../index.html">
    <img src="../images/logo.png" alt="logo">
</a>
Учет зависимости пути от регистра.
В windows имена файлов не зависят от регистра: (cat.JPG и cat.jpg один и тот же файл)
В linux имена файлов зависят от регистра: (cat.JPG и cat.jpg два разных файла)
Задание
Есть структура файлов и папок (директорий)

images/logo.png
pages/about.html
index.html
Есть код, который работает в widows, но не будет работать в linux. Исправь регистр букв в атрибутах href и src
<!-- файл about.html -->
<!-- файл about.html -->
<a href="../index.html">
    <img src="../images/logo.png" alt="logo">
</a>


2 ЧАСТЬ

Список dl из пар dt и dd .
Элемент dl (list) - похож на элементы ul и ol с тем отличием, что вместо одного элемента li внутри dl располагаются пары
из заголовка (title) dt и описания (description) dd

<h4>Проекты Илона Маска</h4>
<dl>
    <dt>SpaceX</dt>
    <dd>Космическая программа</dd>
    <dt>Tesla</dt>
    <dd>Электрический автомобиль с автопилотом</dd>
    <dt>Starlink</dt>
    <dd>Спутниковый интернет-провайдер для всей планеты</dd>
    <dt>Hyperloop</dt>
    <dd>Поезд в вакуумном туннеле</dd>
    <dt>Neuralink</dt>
    <dd>Нейроинтерфейс мозг-компьютер</dd>
</dl>
Проекты Илона Маска
SpaceX
Космическая программа
Tesla
Электрический автомобиль с автопилотом
Starlink
Спутниковый интернет-провайдер для всей планеты
Hyperloop
Поезд в вакуумном туннеле
Neuralink
Нейроинтерфейс мозг-компьютер
Задание
В редакторе html находится текст, состоящий из пар 'название' и 'описание'.

Оформите этот текст в виде списка с помощью тегов dl, dt и dd.

<dl>  

<dt>Тег span.</dt>
<dd>Универсальный контейнер для текстового контента.</dd>
<dt>Тег pre.</dt>
<dd>Сохранение пробелов и переносов.</dd>
<dt>Тег sup и sub.</dt>
<dd>Отображение символов в верхнем и нижнем индексе.</dd>
<dt>Тег strong.</dt>
<dd>Выделение важного слова или целой фразы внутри текста.</dd>
<dt>Тег b.</dt>
<dd>Визульное выделение текста более толстым шрифтом.</dd>
<dt>Тег em.</dt> 
<dd>Семантически и визуально (курсив) выделяет текст.</dd>  
<dt>Тег i.</dt>
<dd>Визуально (курсив) выделяет текст.</dd>
<dt>Тег address.</dt>
<dd>Оборачивает теги с контентом об адресе или получателе.</dd>

</dl>

2. Тег time.
Теория
Внимание
Время в компьютерах отсчитывается в миллисекундах, начиная с т.н. эпохи Unix - с 0 часов, 0 минут 1 января 1970 года

Подробнее

Задание
Добавьте тегу time атрибут datetime со значением полночь на 01 января 1970 года в формате 1970-01-01T00:00

<p>
    Эпоха Unix стартовала в <time datetime="1970-01-01T00:00">полночь на 01 января 1970 года</time>
</p>

Символьные подстановки.
Теория
Символьные подстановки не нужно запоминать, т.к. их много и их довольно легко найти:

Используйте для поиска в ключевые слова: unicode html и название нужной подстановки (или словесное описание
 на что это
похоже).
В поиске нужного ответа на странице поиска используйте ключевое слово HTML Entity, 
HTML-код или мнемоника чтобы выбрать
подходящий для html кода набор символов.
Для css все действия аналогичны. Достаточно заменить html на css в поиске.
Задание
В элемент span добавьте контент - символьную подстановку для registered sign.

<span>&#174;</span>

Аудио.
Задание
Добавьте атрибуты controls, preload="none" для тега audio
Добавьте атрибуты src="https://goit.ua/autocheck/bensound-summer.mp3" и type="audio/mp3" для тега source.

<audio controls preload="none">
    <source src="https://goit.ua/autocheck/bensound-summer.mp3" type="audio/mp3">
</audio>

Верстка таблицы. Теги таблицы и атрибут colspan.
Теория
Изображение таблицы для верстки
таблица
Список тегов таблицы:

table
caption
thead
tbody
tr
th
td
Текст для таблицы:

Как ведут себя block, inline и inline-block
block
inline
inline-block
height определяется
высотой контента
width определяется
шириной родителя
шириной контента
Можно ли задать height и width
можно
нельзя
Как работает перенос на новую строку
всегда с новой строки
только при заполнении ширины родителя
Пример создания таблицы с caption , thead с заголовками из 3-х колонок и tbody с двумя row.

<table>
    <caption>
        Название таблицы
    </caption>
    <thead>
        <tr>
            <th>Заголовок колонки 1</th>
            <th>Заголовок колонки 2</th>
            <th>Заголовок колонки 3</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>Заголовок ряда 1</th>
            <td>Ячейка</td>
            <td>Ячейка</td>
        </tr>
        <tr>
            <th>Заголовок ряда 2</th>
            <td>Ячейка</td>
            <td>Ячейка</td>
        </tr>
    </tbody>
</table>
Название таблицы
Заголовок колонки 1 Заголовок колонки 2 Заголовок колонки 3
Заголовок ряда 1 Ячейка Ячейка
Заголовок ряда 2 Ячейка Ячейка
Пример таблицы c объединением 2-х ячеек после ячейки с текстом "Заголовок ряда 2".

<table>
    <tr>
        <th>Заголовок ряда 1</th>
        <td>Ячейка</td>
        <td>Ячейка</td>
    </tr>
    <tr>
        <th>Заголовок ряда 2</th>
        <td colspan="2">Объединение 2-х ячеек</td>
    </tr>
</table>
Заголовок ряда 1 Ячейка Ячейка
Заголовок ряда 2 Объединение 2-х ячеек
Задание
Сверстай таблицу по ее изображению с помощью тегов и атрибута colspan.

<table>

    <caption>

        Как ведут себя block, inline и inline-block

    </caption>

    <thead>

        <tr>

            <th>/</th>

            <th>block</th>

            <th>inline</th>

            <th>inline-block</th>

        </tr>

    </thead>

    <tbody>

        <tr>

            <th>height определяется</th>

            <td colspan="3">высотой контента</td>



        </tr>

        <tr>

            <th>width определяется</th>

            <td>шириной родителя</td>

            <td colspan="2">шириной контента</td>



        </tr>

        <tr>

            <th>Можно ли задать height и width</th>

            <td>можно</td>

            <td>нельзя</td>

            <td>можно</td>

        </tr>

        <tr>

            <th>Как работает перенос на новую строку</th>

            <td>всегда с новой строки</td>

            <td colspan="2">только при заполнении ширины родителя</td>



        </tr>

    </tbody>

</table>

задание 3

<!--1. Подключение CSS файлов к странице
Внешние CSS файлы подключаются к странице в теге head, используя тег link.

Задание
Напишите элемент link для подключения внешнего файла

который ищет внешний файл с помощью атрибута href по относительному пути css/styles.css;
содержит атрибут rel со значением stylesheet.-->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="css/styles.css" />

</head>

<body>

</body>

</html>

<!--2. Синтаксис CSS правила
синтаксис CSS правила

Внимание
Всегда добавляйте точку с запятой во всех CSS правилах, даже если синтаксис позволяет не добавлять ';' для последнего
правила.

Задание
Для селектора p задайте свойство color и значение red, свойство font-size и значение 20px;-->

<p>По умолчанию в браузере цвет текста - черный</p>
<p>По умолчанию в размер шрифта текста - 16px</p>

<!--3. Селекторы и вес селектора: любой элемент, приоритет без ранга
Многие элементы (заголовки к примеру) имеют установленные браузером margin и padding. Удобно производить сброс этих
значений до 0. Для этой цели подходит селектор с наименьшим приоритетом и одновременно такой, что задает правила для
всех элементов (исключая псевдоэлементы, но об этом позже).

Такой селектор задается символом * - т.е. любой элемент. Приоритет у такого селектора минимальный (без ранга).

Внимание
Если значение какого-либо свойства равно 0, то указывать единицу измерения, вроде `px` не обязательно и даже
нежелательно.

Задание
Для селектора * (любой элемент) задай свойство margin и значение 0, свойство padding и значение 0; -->

<ul>
    <li>По умолчанию многие элементы (напрмер заголовки) могут иметь значения `margin` отличные от `0`</li>
    <li>По умолчанию у списка `padding-left` равен `40px`</li>
</ul>
<!--* {
margin: 0;
padding: 0;
} -->

<!-- 4. Селекторы и вес селектора: тег, приоритет 4-го ранга
Теория
Приоритет 4-го ранга минимальный (но он выше селектора без ранга). 4-й ранг принадлежит селекторам элемента и псевдоэлемента (что это - узнаем позднее).
Внимание
Селектор тега использовать нежелательно. Подходящим случаем для выбора тега в качестве селектора является необходимость отмены или обнуления стилей внутри документа.
Задание
Для тега li отмени свойство  list-style с помощью значения none. Задай свойству color значение green; Убедись на примере изменения цвета текста, что у тега более высокий приоритет, чем у *. -->

<ol>
    <li>У списка можно отменить оформление по умолчанию</li>
    <li>У списка можно отменить оформление по умолчанию</li>
</ol>
<ul>
    <li>У списка можно отменить оформление по умолчанию</li>
    <li>У списка можно отменить оформление по умолчанию</li>
</ul>
* {color: red; }
li {
list-style: none;
color: green;
}
<!-- 5. Селекторы и вес селектора: класс, приоритет 3-го ранга
Теория
Приоритет 3-го ранга выше приоритета 4-го ранга. 3-й ранг принадлежит селекторам класса и псевдокласса (что это - узнаем позднее).
Задание
Для класса rule задай задай свойство  list-style и значение upper-roman, свойство color и значение navy;
Убедись на примере появления римской нумерации и изменения цвета текста, что у класса более высокий приоритет, чем у тега. -->
<ol class="rules">
    <li class="rule">Класс - основной селектор для оформления стилей</li>
    <li class="rule">У класса более высокий приоритет, чем у тега</li>
    <li class="rule">Избегай по возможности сложных селекторов, например сочетания тега и класса</li>
    <li class="rule">Лучший селектор - это один класс. Но это не всегда возможно.</li>
</ol>

li {
list-style: none;
color: green;
}
.rule {
list-style: upper-roman;
color: navy;
}

<!-- 6. Селекторы и вес селектора: избегаем повторения кода
Теория
Если у элементов есть общие и уникальные правила, то лучшей практикой является создавать для общих правил один отдельный класс и несколько классов для уникальных правил.
Подход объединения общего и отделение уникального позволяет избегать повторения кода, что в компьютерных науках называют принципом DRY (don't repeat yourself) - не повторяй свой код. Это один из самых важных принципов для написания простого, понятного и легко поддерживаемого кода, с минимальным количеством ошибок. Его можно применять не только к CSS и классам, но и в большинстве языков программирования, например в JavaScript.
Задание
Двум элементам с классом common-rule добавлены классы first-rule и last-rule, т.е. создана композиция с классом common-rule.
Добавьте CSS правила для класса first-rule и last-rule под текстом с правилом для класса common-rule (почему именно такое расположение будет рассмотрено позже).
Для класса first-rule добавьте свойство color и значение red.
Для класса last-rule добавьте свойство color и значение green.
 -->
<ol class="rules">
    <li class="common-rule first-rule">Класс - основной селектор для оформления стилей</li>
    <li class="common-rule ">У класса более высокий приоритет, чем у тега</li>
    <li class="common-rule">Избегай по возможности сложных селекторов, например сочетания тега и класса</li>
    <li class="common-rule last-rule">Лучший селектор - это один класс. Но это не всегда возможно.</li>
</ol>
.common-rule {
list-style: upper-roman;
font-size: 20px;
}
.first-rule {color: red;}
.last-rule {color: green;}

<!-- 7. Селекторы и вес селектора: композиций классов, приоритет через суммирование разрядов
Теория
Если селектор должен выбрать элемент в котором находятся одновременно два класса, то такой селектор выглядит как запись двух классов подряд без пробела.
"Вес" такого селектора будет выше, чем у селекторов с одним классом. Чем больше селекторов одного ранга, тем выше специфичность ("вес селектора"). Из нескольких правил css применится то правило, у которого специфичность выше.
Полезно
Чем выше специфичность (или "вес") селектора, тем труднее изменить правило при необходимости. Рост размера селекторов приводит к трудностям в поддержке из-за лишней сложности. Поэтому нужно стремиться к заданию минимальной специфичности в виде селектора из одного класса, насколько это возможно.
Пример:
<h1 class="title headline">Заголовок 1</h1>
<h2 class="headline">Заголовок 2</h2>
<h2 class="title">Заголовок 3</h2>
.title.headline {
  font-family: cursive;
}
.title {
  font-family: serif;
}
.headline {
  font-family: sans-serif;
}
Заголовок 1
Заголовок 2
Заголовок 3
Задание
В CSS добавь класс active к селекторам button и link так, чтобы
правило color: red применилось только к элементу button, содержащему одновременно класс btn и active;
правило font-weight: 700 применилось только к элементу a, содержащему одновременно класс link и active.
 -->

<button class="btn" type="button">Да</button>
<button class="btn active" type="button">Нет</button>
<a class="link" href="#">Ссылка 1</a>
<a class="link active" href="#">Ссылка 2</a>

.btn {
border: none;
padding: .25rem 1.25rem;
}

.link {
text-decoration: none;
color: navy;
}
/* Напиши свой код под этой строкой */
.btn.active {
color: red;
}

.link.active {
font-weight: 700;
}
<!-- 8. Селекторы и вес селектора: псевдокласс, приоритет 3-го ранга
Если требуется перечислить два разных селектора для одного набора CSS правил, то используют запятую:

<a class="link" href="#">ссылка</a>
<button class="btn" type="button">да</button>
.link,
.btn {
color: red;
}
Класс и псевдокласс имеют одинаковую специфичность. Но так, как псевдокласс, как правило, добавляют к классу, то общий
"вес" такого селектора будет выше (3-й ранг + 3-й ранг = 2 * 3-й ранг), чем у селекторов с одним классом (1 * 3-й ранг).

Задание
Добавь псевдокласс :hover и :focus так, чтобы для класса link применялось свойство opacity: 1 при наведении курсора или
получения фокуса с помощью клавиши tab -->

<a class="link" href="#">Ссылка 1</a>
<a class="link" href="#">Ссылка 2</a>

.link {
text-decoration: none;
color: navy;
opacity: 0.5;
}
/* Напиши свой код под этой строкой */
.link:hover, .link:focus {
opacity: 1;
}

<!--9.Селекторы и вес селектора: атрибут, приоритет 3-го ранга
Класс и атрибут имеют равный "вес" селектора. В CSS при одинаковой специфичности (равном "весе" селекторов) применятся то правило, которое будет написано ниже в тексте (выполнится позже в потоке выполнения документа).

Селектор атрибута должен находиться внутри квадратных скобок и может содержать название атрибута или название и значение атрибута.

Пример
<a href="#">ссылка</a>
<img src="img.jpg">
[src] {
  display: block;
  width: 100%;
}

[href="#"] {
  color: red;
}
Для повышения специфичности можно записывать составной селектор, состоящий из класса и атрибута.

Пример
<a class="link" href="#">ссылка</a>

.link[href="#"] {
  color: red;
}
Задание
Для селектора в виде атрибута [type] задай свойство color со значением white.
Повышаем специфичность. Для селектора в виде тега button и атрибута [type="reset"] задай свойство color со значением green -->

<button class="btn" type="button">продолжить</button>
<button class="btn" type="reset">по умолчанию</button>
<button class="btn" type="submit">отправить</button>
<a class="btn" href="./help.html">помощь</a>

[type] {color: white; }
button[type="reset"]{color: green;}

<!--10.Селектор атрибута: символ ^
Символ ^ для выбора тех значений атрибута, которые начинаются с определенных символов

Если требуется выделить атрибут, значение которого начинается с какого-то значения, то синтаксис такого селектора содержит ^ перед знаком равно и текст, с которого начинается значение атрибута

Селектор атрибута должен находиться внутри квадратных скобок.

Пример
<a class="link" href="./index.html">На главную страницу</a>
<a class="link" href="#ancor">ссылка на элемент страницы с заданным id</a>
<section id="ancor">...</section>

/* "#ancor" начинается с "#" */
[href^="#"] {
  color: red;
}
Задание
Для ссылок с атрибутом href, значение которых начинается с ./ задай цвет текста red.
Для ссылок с атрибутом href, значение которых начинается с https задай цвет текста navy.
Специфичность селекторов должна быть минимальной.-->

ul>
<li>
    <a class="link" href="./index.html">На главную</a>
</li>
<li>
    <a class="link" href="./about.html">О нас</a>
</li>
<li>
    <a class="link" href="./contats.html">Контакты</a>
</li>
</ul>

<ul>
    <li>
        <a class="link" href="https://www.google.com">Google</a>
    </li>
    <li>
        <a class="link" href="https://developer.mozilla.org/ru/docs/web/css">MDN + CSS</a>
    </li>
    <li>
        <a class="link" href="https://stackoverflow.com/questions/tagged/css">StackOverflow + CSS</a>
    </li>
</ul>
.link {
text-decoration: none;
}
[href^="./"]{color: red;}
[href^="https"]{color: navy;}

<!--11.Селектор атрибута: символ $
Cимвол `` для выбора тех значений атрибута, которые заканчиваются на определенные символы.

Если требуется выделить атрибут, значение которого в конце имеет определенный символ (или символы), то синтаксис такого селектора содержит

$ перед знаком равно
и текст, который ожидается в конце значения.
Селектор атрибута должен находиться внутри квадратных скобок.

Пример
<a class="link" href="./index.html">На главную страницу</a>
<a class="link" href="#ancor">ссылка на элемент страницы с заданным id</a>
<section id="ancor">...</section>
/* "#ancor" заканчивается на "cor" */
[href$="cor"] {
  color: red;
}
На главную страницу ссылка на элемент страницы с заданным id
...
Задание
Для атрибутов, заканчивающихся на html задай цвет текста green.
Для атрибутов, заканчивающихся на css задай цвет текста orangered.
Специфичность селекторов должна быть минимальной.-->

<ul>
    <li>
        <a class="link" href="./index.html">На главную</a>
    </li>
    <li>
        <a class="link" href="./about.html">О нас</a>
    </li>
    <li>
        <a class="link" href="./contats.html">Контакты</a>
    </li>
</ul>

<ul>
    <li>
        <a class="link" href="https://www.google.com">Google</a>
    </li>
    <li>
        <a class="link" href="https://developer.mozilla.org/ru/docs/web/css">MDN + CSS</a>
    </li>
    <li>
        <a class="link" href="https://stackoverflow.com/questions/tagged/css">StackOverflow + CSS</a>
    </li>
</ul>

.link {
text-decoration: none;
}
[href$="html"]{color: green;}
[href$="css"]{color: orangered;}

<!--12.Селектор атрибута: символ *
Символ * для выбора тех значений атрибута, которые включают определенные символы

Если требуется выделить атрибут, в значении которого включен какой-то текст, то синтаксис такого селектора содержит * перед знаком равно и сам текст.

Селектор атрибута должен находиться внутри квадратных скобок.

Пример
<a class="link" href="./index.html">На главную страницу</a>
<a class="link" href="#introduction">ссылка на элемент страницы с заданным id</a>
<a class="link" href="#article">ссылка на элемент страницы с заданным id</a>
<section id="introduction">...</section>
<section id="article">...</section>

/* "in" содержится в  "./index.html" и в "#introduction",
  но не в "#article" */
[href*="in"] {
  color: red;
}
Задание
Для атрибутов, содержащих about задай цвет текста green.
Для атрибутов, содержащих com задай цвет текста orangered.
Специфичность селекторов должна быть минимальной.-->
<ul>
    <li>
        <a class="link" href="./index.html">На главную</a>
    </li>
    <li>
        <a class="link" href="./about-book.html">О книге</a>
    </li>
    <li>
        <a class="link" href="./about-author.html">Об авторе</a>
    </li>
</ul>

<ul>
    <li>
        <a class="link" href="https://www.google.com/">Google</a>
    </li>
    <li>
        <a class="link" href="https://developer.mozilla.org/ru/docs/web/css">MDN + CSS</a>
    </li>
    <li>
        <a class="link" href="https://stackoverflow.com/questions/tagged/css">StackOverflow + CSS</a>
    </li>
</ul>
.link {
text-decoration: none;
}
[href*="about"]{color: green;}
[href*="com"]{color: orangered;}

<!--13.Селекторы и вес селектора: id, приоритет 2-го ранга
Приоритет 2-го ранга выше приоритета 3-го ранга. Такой селектор нежелательно использовать для создания CSS правил из-за того что стили задаются классами, т.е. селекторами 3-го ранга, а 2-й ранг переопределит стили без возможности изменить любым количеством селекторов 3-го ранга (т.е. даже композиция из 64 тысяч классов не изменит значения у id селектора ).

id активно применяются в html формах, в JS и т.п., но использование селектора id в css правилах является плохой практикой из-за более высокого приоритета этого селектора по сравнению с классом.

Задание
Добавь CSS правило с id селектором sending со свойством background-color и значением teal, со свойством color и значением white.

Обрати внимание на то что у id более высокий приоритет, чем у класса.-->

<div class="warning" id="sending">Использование id в качестве селектора в большинстве случаев является плохой практикой.
    Потому что приводят к дублированию кода и, как следствие, к излишней сложности кода.</div>

.warning {
background-color: white;
color: red;
}
#sending {background-color: teal; color: white;}


<!--14.Инлайн стили, приоритет 1-го разряда
Приоритет 1-го ранга выше приоритета 2-го ранга. 1-й ранг принадлежит селекторам атрибута style внутри html элемента. Обратите внимание что атрибут class имеет 3-й ранг, а атрибут id - 2-й ранг.

Атрибут style как правило используется в JavaScript, наравне с использованием стилей через добавлением или удалением классов.

Внимание
Предпочтительно стили задавать через классы, т.к. это упрощает разработку и поддержку веб-приложения.

Задание
Задайте элементу div инлайн стили CSS со свойством background-color и значением orange, со свойством color и значением navy.

Обратите внимание на более высокий приоритет у инлайн-стилей по сравнению с классом и id.-->

<div class="warning" id="inline" style="background-color: orange; color: navy;">Инлайн стили нежелательно использовать из-за более высокого приоритета чем у
    id, а также из-за сложности c поддержкой и переиспользованем кода.</div>

.warning {
background-color: white;
color: red;
}
#inline {
background-color: teal;
color: white;
}
<!--15.!important, приоритет с повышением ранга селектора.
Значение !important добавляется после значения css свойства через пробел.

Внимание
Использование этого способа изменить приоритет является плохим тоном и не рекомендуется к применению. В данном задании мы знакомим с этим приемом для понимания самого механизма изменения приоритета.

Пример:
a {
  color: red !important;
}
<div style="color: navy !important;">Это css свойство невозможно ничем переопределить, т.к. сочетание инлайн и `!important` создают высший приоритет. Не используйте такой способ!</div>
Расчет приоритета при применении значения !important происходит так, словно рангу селектора добавилось еще 4-ре ранга с более высоким приоритетом. Что-то вроде добавления приставки 0.

Например

у тега приоритет 4-го ранга, после добавления !important ранг станет 04. Т.е. выше 1-го, 2-го, 3-го и 4-го рангов.
у класса приоритет 3-го ранга, после добавления !important ранг станет 03. Т.е. выше 04-го, 1-го, 2-го, 3-го и 4-го рангов.
у id приоритет 2-го ранга, после добавления !important ранг станет 02. Т.е. выше 03-го, 04-го, 1-го, 2-го, 3-го и 4-го рангов.
у инлайн приоритет 1-го ранга, после добавления !important ранг станет 01. Т.е. выше 02-го, 03-го, 04-го, 1-го, 2-го, 3-го и 4-го рангов.
Задание
Добавь !important обеим значениям свойств селектора div.

Обрати внимание на то что у div приоритет изменился и стал более высоким чем у инлайн.-->

<div class="warning" id="inline" style="background-color: orange; color: navy;">Использование !important крайне
    нежелательно. Этот способ повысить приоритет до неизменяемого применяют обычно только для оформления предупреждений
    или сообщений об ошибках приложения.</div>

div {
background-color: navy!important;
color: white!important;
}
.warning {
background-color: white;
color: red;
}
#inline {
background-color: red;
color: white;
}

<!--16.Селекторы отношений по родству. Прямой потомок.
Прямой потомок элемента в селекторе задается с помощью символа >

Пример:
<section>
  <div>
    <h4>Заголовок</h4>
  </div>
</section>
section > div {}
div > h4 {}
Задание
Добавь к селектору menu-item еще один класс menu так, чтобы оба свойства display и vertical-align применились только к прямым потомкам класса menu, но не к потомкам sub-menu. -->

<ul class="menu">
    <li class="menu-item">
        <a href="#" class="menu-link">Меню 1</a>
    </li>
    <li class="menu-item">
        <ul class="sub-menu">
            <li class="menu-item">
                <a href="#" class="menu-link">Sub Меню 1</a>
            </li>
            <li class="menu-item">
                <a href="#" class="menu-link">Sub Меню 2</a>
            </li>
            <li class="menu-item">
                <a href="#" class="menu-link">Sub Меню 3</a>
            </li>
        </ul>
        <a href="#" class="menu-link">Меню 2</a>
    </li>
    <li class="menu-item">
        <a href="#" class="menu-link">Меню 3</a>
    </li>
</ul>
ul {
padding: 0;
list-style: none;
}

.menu>.menu-item {
display: inline-block;
vertical-align: top;
}

<!--17.Селекторы отношений по родству. Любой потомок.
Любой потомок элемента в селекторе задается с помощью пробела между селектором элемента и его потомками любого уровня вложенности.

Первый потомок элемента задается символом > между селектором элемента и селектором потомка.

Пример:
<section>
  <div class="first">
    <h4>Заголовок</h4>
    <div> Непрямой потомок section</div>
  </div>
  <div class="first">1</div>
</section>
Любой потомок для элемента section это все div и h4:

section  div {}
section  h4 {}
Первый потомок для элемента section это div с классом first:

section > div {}
Задание
В html коде дано меню, которое содержит два подменю, вложенных одно в другое. В css кода все подменю с классом sub-menu скрыты с помощью свойства opacity. Необходимо разместить элементы li списка с классом menu по горизонтали, а li списков с классом sub-menu должны остаться в вертикальном положении. Также при наведении курсором на элемент li должно показываться скрытое меню.

Для этого

Добавь к селектору menu все элементы с селектором класса menu-item, которые являются первыми потомками списка с классом menu.
Добавь к селектору sub-menu все элементы с селектором класса menu-item, которые являются потомками списка с классом sub-menu на любом уровне вложенности.
Добавь к селектору menu-item:hover все элементы, которые являются потомками элемента с классом menu-item на любом уровне вложенности.
Обрати внимание на поведение элементов меню при hover до и после успешного выполнения задания.-->

<ul class="menu">
    <li class="menu-item">
        <a href="#" class="menu-link">Меню 1</a>
    </li>
    <li class="menu-item">
        <a href="#" class="menu-link">Меню 2 ▼</a>
        <ul class="sub-menu">
            <li class="menu-item">
                <a href="#" class="menu-link">Sub Меню 1</a>
            </li>
            <li class="menu-item">
                <a href="#" class="menu-link">Sub Меню 2 ▼</a>
                <ul class="sub-menu">
                    <li class="menu-item">
                        <a href="#" class="menu-link">Sub Меню 1</a>
                    </li>
                    <li class="menu-item">
                        <a href="#" class="menu-link">Sub Меню 2</a>
                    </li>
                    <li class="menu-item">
                        <a href="#" class="menu-link">Sub Меню 3</a>
                    </li>
                </ul>
            </li>
            <li class="menu-item">
                <a href="#" class="menu-link">Sub Меню 3</a>
            </li>
            <li class="menu-item">
                <a href="#" class="menu-link">Sub Меню 4</a>
            </li>
        </ul>
    </li>
    <li class="menu-item">
        <a href="#" class="menu-link">Меню 3</a>
    </li>
</ul>

ul {
padding: 0;
list-style: none;
}

.menu > .menu-item {
display: inline-block;
vertical-align: top;
opacity: 1;
}

.sub-menu .menu-item {
opacity: 0;
margin-left: 100px;
}

.menu-item:hover .menu-item {
opacity: 1;
}
<!--18.Селекторы отношений по соседству. Первый сосед.
Отсчет соседства связан с потоком выполнения - т.е. началом отсчета соседства считается элемент, который написан и прочитан браузером первым. Первый сосед в селекторе задается с помощью символа +

Примеры с объяснением какой элемент является первым соседом.

Пример:
<section class="first">
  Элемент
</section>
<section class="first-neighbor">
  1-й сосед
</section> 
<section class="second-neighbor">
  2-й сосед
</section> 
<section class="third-neighbor">
  3-й сосед
</section> 
Запишем селектор соседства для элемента section с классом first так, чтобы был выбран элемент с классом first-neighbor

.first + section {color: red;}
Элемент
1-й сосед
2-й сосед
3-й сосед
Задание
Добавь к селектору item-1 еще один класс item так, чтобы свойство color: red применилось только к первому соседу - элементу с классом item-2-->

<ul class="items">
    <li class="item item-1">1-й сосед</li>
    <li class="item item-2">2-й сосед</li>
    <li class="item item-3">3-й сосед</li>
    <li class="item item-4">4-й сосед</li>
</ul>

.item-1 + .item{
color: red;
}

<!--19.Селекторы отношений по соседству. Любой нижний сосед.
Отсчет соседства связан с потоком выполнения - т.е. соседними элементами считаются все элементы, написанные в коде после заданного селектором и имеющие общего прямого родителя. Любой нижний сосед для селектора задается с помощью символа ~

Примеры с объяснением какой элемент является первым соседом.

Пример:
<section class="zero">сосед сверху</section>
<section class="first">Элемент</section>
<section class="first-neighbor">1-й сосед</section> 
<section class="second-neighbor">2-й сосед</section> 
<section class="third-neighbor">3-й сосед</section> 
Запишем селектор соседства для класса first так, чтобы чтобы был выбран элемент с классами first-neighbor, second-neighbo и third-neighbor:

.first ~ section {
  color: red;
}
сосед сверху
Элемент
1-й сосед
2-й сосед
3-й сосед
Задание
Добавь к селектору item-2 еще один класс item так, чтобы свойство color со значением red применилось ко всем нижним соседям этого элемента.

Т.е. правило должно примениться к элементам с классом item-3 и item-4.

Ни к каким другим элементам color: red больше применяться не должно.-->

<ul class="items">
    <li class="item item-1">1-й сосед</li>
    <li class="item item-2">2-й сосед</li>
    <li class="item item-3">3-й сосед</li>
    <li class="item item-4">4-й сосед</li>
</ul>
.item-2 ~ .item{
color: red;
}

<!--20.Каскад. Приоритет при равенстве селекторов.
Если есть свойство, для которого записано несколько CSS правил с селекторами одинакового "веса", то значения будут перезаписаны и в итоге применится значение из написанного последним CSS правила.

Задание
Не меняя селекторы и правила CSS сделай так, чтобы цвет текста всех элементов стал maroon (перемести CSS правила).-->

<h4 class="title headline" title="1">1</h4>
<h4 class="title headline" title="2">2</h4>
<h4 class="title headline" title="3">3</h4>

.headline.title{
color: navy;
}

.title[title] {
color: maroon;
}

<!--21.Каскад. Наследование.
Некоторые свойства CSS могут передавать значение элементам html, являющимися потомками элемента выделенного селектором. Например цвет текста - наследуется (за некоторыми исключениями, одному из которых посвящено следующее задание ).

Задание
В коде html есть элемент ul с классом cards и есть последний элемент li с классом last-of-type. С помощью наследования нужно изменить цвет текста для элементов-потомков этих двух элементов. Для этого необходимо:

селектору класса cards задать цвет текста navy;
селектору класса last-of-type задать цвет текста firebrick.-->

<ul class="cards">
    <li class="card">
        <h4 class="card-title">Заголовок карточки 1</h4>
        <p class="card-description">
            Текст - описание для карточки 1.
        </p>
    </li>
    <li class="card">
        <h4 class="card-title">Заголовок карточки 2</h4>
        <p class="card-description">
            Текст - описание для карточки 2.
        </p>
    </li>
    <li class="card last-of-type">
        <h4 class="card-title">Заголовок карточки 3</h4>
        <p class="card-description">
            Текст - описание для карточки 3.
        </p>
    </li>
</ul>

.cards {color: navy;}
.last-of-type {color: firebrick;}

<!--22.Каскад. Исключения в наследовании.
Цвет текста для ссылок не наследуется. Если свойство не наследуется, то такое свойство для элемента надо задать отдельно.

Задание
Т.к. цвет текста для ссылок не наследуется, то задай ссылке цвет green, используя класс в качестве селектора-->

<ul class="list">
    <li class="list-item">По умолчанию в браузере цвет текста - черный</li>
    <li class="list-item"><a class="list-link" href="#">По умолчанию в браузере цвет ссылки - синий с подчеркиванием</a>
    </li>
    <li class="list-item">По умолчанию у списка `padding-left` равен `40px`</li>
</ul>

.list {
padding-left: 0;
list-style: none;
color: green;
}
.list-link {color: green;}

<!--23.Подключение CSS файлов к странице
Т.к. правила CSS с равными селекторами, но записанными в тексте последними, перезапишут предыдущие значения для одинаковых свойств, то порядок подключения файлов CSS имеет значение.

Файл modern-normalize переопределяет некоторые стили браузера для удобства работы.

Задание
Подключите в правильном порядке файлы стилей, расположенных в папке css:

css/modern-normalize.css
css/style.css-->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="css/modern-normalize.css">
    <link rel="stylesheet" href="css/style.css">

</head>

<body>

</body>

</html>

<!--24.Цвет в CSS: rgb
Цвет текста задается свойством color

Цвет фона задается свойством background-color

Значением этого свойства может быть запись в 4-х форматах

именованные цвета (black, white и т.д)
rgb цвета (rgb(0,0,0), rgb(255,255,255) или rgb(100%,100%,100%) и т.д)
hex цвета (#000 или #000000, #fff или #ffffff и т.д)
hsl цвета (hsl(0,0%,0%), hsl(0,0%,100%) и т.д)
Именованные цвета не рекомендуется использовать из-за более долгой обработки такой записи браузером, но они очень удобны для демонстрации примеров работы CSS.

Формат rgb наиболее интуитивно понятен, и его чаще используют при копировании цвета из макета.

Формат hex занимает меньше места и его используют с целью сокращения объема файла.

Формат hsl удобен для получения оттенков цвета и его используют для создания палитр, теней и т.п.

В rgb используется три цвета: r - red, g - green, b - blue.

Все три цвета можно задать числами в диапазоне

от 0 до 255
от 0% до 100%
Внимание
Именованный цвет green не совпадает с максимальным значением зеленого цвета в `rgb`, `hex` или `hsl` формате

Задание
В формате rgb, используя только значения от 0 до 255:

задай классу box белый цвет текста и черный фон
задай классу red максимально красный фон
задай классу green максимально зеленый фон
задай классу blue максимально синий фон-->

<div class="box">Белый текст на черном фоне.</div>
<div class="box red">Белый текст на красном фоне.</div>
<div class="box green">Белый текст на зеленом фоне.</div>
<div class="box blue">Белый текст на синем фоне.</div>

.box {
background-color: rgb(0, 0, 0);
color: rgb(255, 255, 255);
}

.red {
background-color: rgb(255, 0, 0);
}

.green {
background-color: rgb(0, 255, 0);
}

.blue {
background-color: rgb(0, 0, 255);
}

<!--25.Цвет в CSS: hex
Цвета в hex формате задаются с помощью символа # и перечислением значений цветов по порядку - красный, зеленый, синий. Значения записываются в 16-ричном формате.

Все три цвета можно задать числами в диапазоне от 0 до ff (ff это 255 в 16-ричной системе счисления). Всего получается 7 символов, включая #:

a {color: #11aabb}
Если все три цвета состоят из одинаковых символов, то рекомендуется сократить запись - по одному символу на один цвет:

/* тот же цвет в сокращенной записи*/
a {color: #1ab}
Задание
В сокращенном hex формате

задай классу box белый цвет текста и черный фон;
задай классу red максимально красный фон;
задай классу green максимально зеленый фон;
задай классу blue максимально синий фон.-->

<div class="box">Белый текст на черном фоне.</div>
<div class="box red">Белый текст на красном фоне.</div>
<div class="box green">Белый текст на зеленом фоне.</div>
<div class="box blue">Белый текст на синем фоне.</div>

.box {
background-color: #000;
color: #fff;
}

.red {
background-color: #f00;
}

.green {
background-color: #0f0;
}

.blue {
background-color: #00f;
}

<!--26.Цвет в CSS: hsl
Цвет hsl имеет необычные параметры, но достаточно научиться управлять третьим параметром lightness или яркостью, чтобы получать более темные или светлые оттенки выбранного цвета и при этом всегда попадать в правильный тон, гармонично сочетающийся с исходным цветом. Это может понадобится для ситуации, когда hover не прорисован для всех цветов темы. В таких случаях достаточно перевести цвет в формат hsl и изменить lightness на 10% или более процентов.

При смене темы стоит уделять внимание контрастности цвета фона и цвета текста - если фон темный, то надо подбирать светлый цвет для текста и наоборот.

Текст без коррекции контраста с фоном:

h. s. lightness
100%
75%
50%
25%
0
Текст после коррекции контраста с фоном:

h. s. lightness
100%
75%
50%
25%
0
Задание
Сделай цвет текста контрастным - добавь белый цвет в формате hsl для классов lightness-25 и lightness-0-->

<h2>h. s. lightness</h2>
<div class="lightness lightness-100">100%</div>
<div class="lightness lightness-75">75%</div>
<div class="lightness lightness-50">50%</div>
<div class="lightness lightness-25">25%</div>
<div class="lightness lightness-0">0</div>

.lightness {
width: 50px;
height: 50px;
line-height: 50px;
margin: 0.5rem;
text-align: center;
border: 1px solid gold;
}
.lightness-100 {
background-color: hsl(0, 100%, 100%);
}
.lightness-75 {
background-color: hsl(0, 100%, 75%);
}
.lightness-50 {
background-color: hsl(0, 100%, 50%);
}
.lightness-25 {
background-color: hsl(0, 100%, 25%);
color: hsl(0, 100%, 100%);
}
.lightness-0 {
background-color: hsl(0, 100%, 0%);
color: hsl(0, 100%, 100%);
}

<!--27.Прозрачность: opacity и transparent
Отличие между свойством opacity и цветом прозрачности transparent:

opacity меняет прозрачность всех свойств элемента, связанных с цветом, а также прозрачность потомков элементов. Это ограничивает возможность применения свойства.

transparent это название цвета 'прозрачный', подобно названию белый - white или черный - black. Поэтому такое название можно применять для цвета текста, фона и т.п.

Пример наследования opacity

Opacity: 1
Opacity: .5
Opacity: .1
Задание
Задай свойство opacity селекторам .opacity:hover и .opacity:focus так, чтобы прозрачность отсутствовала.
Задай свойству background-color селекторам .transparent:hover и .transparent:focus значение - именованный цвет прозрачности.-->

<div class="container">
    <div class="box opacity">Opacity</div>
    <div class="box transparent">Transparent</div>
</div>

.container {
padding: 1rem;
background-color: navy;
}

.box {
width: 200px;
height: 50px;
margin: 1rem auto;
color: #fff;
font-size: 24px;
line-height: 50px;
text-align: center;
cursor: pointer;
background-color: orchid;
border: 4px solid gold;
}

.opacity {
opacity: .5;
}

.opacity:hover,
.opacity:focus {
opacity: 1;

}

.transparent:hover,
.transparent:focus {
background-color: transparent;

}

<!--28.Прозрачность: альфа-канал
Чтобы получить удобство opacity в получении градаций прозрачности, но иметь возможность применять прозрачность только к определенному цвету используют альфа-канал. Это особый синтаксис для знакомой записи цвета в форматах rgb, hsl и hex.

В предыдущем примере мы выяснили, что недостаток transparensy - отсутствие градаций, а недостаток opacity - неизбирательность (применятся ко всем цветам).

Чтобы избавиться от этих недостатков к форматам rgb, hsl и hex можно добавить 4-е значение - прозрачность или по другому - альфа-канал.

Синтаксис записи цвета с альфа-каналом:

rgba: rgba(Red,Green,Blue, Alfa), где значения Alfa меняется как у свойства opacity, т.е. от 0 до 1 с помощью дробных чисел. Например .5 - полупрозрачность.
hsla: hsla(Color, Saturation, Lightness, Alfa), где значения Alfa меняется как у свойства opacity, т.е. от 0 до 1 с помощью дробных чисел. Например .5 - полупрозрачность.
hexa: #RRGGBBAA), где AA - значения Alfa. Это меняется как у opacity , но в 16-ричном формате. Т.е. от 0 до FF. Например .5 = 80.
Задание
Задай свойству background-color селектору [data-color="rgba"]:hover значение - полупрозрачный цвет в формате rgba вместо заданного в формате rgb.
Задай свойству background-color селектору [data-color="hsla"]:hover значение - полупрозрачный цвет в формате hsla вместо заданного в формате hsl.
Задай свойству background-color селектору [data-color="hexa"]:hover значение - полупрозрачный цвет в формате hexa вместо заданного в формате hex.-->

<button data-color="rgba">rgba</button>
<button data-color="hsla">hsla</button>
<button data-color="hexa">hexa</button>

[data-color] {
padding: 0.5rem 1.5rem;
border: none;
background-color: #008;
color: #fff;
font-size: 1.5rem;
}

[data-color="rgba"]:hover {
background-color: rgba(0, 0, 136, 0.5);
}


[data-color="hsla"]:hover {
background-color: hsla(240, 100%, 27%, .5);
}


[data-color="hexa"]:hover {
background-color: #00008a80;
}

4. Teil.
<!--1.Текст: text-indent
Теория
Пример отступа для первой строки (выделена красным цветом) абзаца. Подобный эффект достигается с помощью свойства text-indent.

Задание
Для текста абзаца (параграфа)
задай селектор в виде имени тега ;
сделай отступ первой строки на 40px.-->

<p>Свойство <em>text-indent</em> определяет размер отступа (пустого места) перед строкой в текстовом блоке. По умолчанию
    это свойство управляет отступом только первой строки блока.</p>
p {text-indent: 40px;}

<!--2.Текст: наследование свойств column-count и text-indent
Теория
Зрение человека устроено так, что комфортно читать можно строку, которая не превышает 75-90 знаков. По этой причине газетные публикации разбивают на колонки. И по этой причине в css также можно разбить текст на колонки, регулируя число колонок (или ширину колонок).
Наследование - такие свойства как text-indent и column-count могут наследоваться. Т.е. их можно задать одному общему предку и все потомки получат это свойство.

Задание
Используй название класса columns в качестве селектора.
Добавь css свойство text-indent с отступом первой строки абзаца в 40px.
Добавь css свойство column-count значение для создания 2-х колонок.-->
<div class="columns">
    <p>CSS свойство <em>column-count</em> разбивает содержимое элемента на заданное число столбцов.
    </p>
    <p>Свойство CSS <em>column-width</em> устанавливает ширину столбца в многоколоночном макете. В контейнере будет
        столько столбцов, сколько может поместиться. Если ширина контейнера уже указанного значения, ширина отдельного
        столбца будет меньше, чем заявленная ширина столбца.</p>
    <p>Свойство CSS <em>column-gap</em> устанавливает размер промежутка между столбцами элемента.
    </p>
</div>

.columns {text-indent: 40px;
column-count: 2;}

<!--3.Текст: горизонтальное выравнивание
Теория
Свойство: text-align Значения:
left
right
justify
center
Это свойство применятся как к тексту, так и к элементам со свойством display и значением inline или inline-block. Например к button.

Задание
Размести текст и элементы button внутри элементов div с помощью свойства text-align в определенном горизонтальном порядке:
для элемента с классом left строчные элементы или текст должны быть прижаты влево;
для элемента с классом right строчные элементы или текст должны быть прижаты вправо;
для элемента с классом center строчные элементы или текст должны находиться по центру элемента div;
для элемента с классом justify строчные элементы или текст должны быть растянуты на всю ширину элемента div, если строка заполнена.-->
<div class="left">
    <button>да</button>
    <button>нет</button>
    <button>отменить</button>
</div>
<div class="right">
    <button>да</button>
    <button>нет</button>
    <button>отменить</button>
</div>
<div class="center">
    <button>да</button>
    <button>нет</button>
    <button>отменить</button>
</div>
<div class="justify">
    Строчные элементы ведут себя подобно буквам текста и к ним можно применять те же самые css правила. Например button
    : <button>да</button>
    <button>нет</button>
    <button>отменить</button>. Такое поведение можно использовать для центрирования кнопок, разместив кнопку внутри
    обертки и задав text-align: center родительскому блоку.
</div>

.left { text-align: left; }
.right {text-align: right;}
.center {text-align: center;}
.justify {text-align: justify;}

<!-- 4.Текст: межстрочный интервал
Теория
Межстрочный интервал (расстояние между строк) состоит из суммы значений font-size и line-height.
font-size задает высоту прямоугольника, в котором должен отображаться глиф (изображение символа). Глиф может быть меньше прямоугольника, но иногда и больше. Т.е. значение font-size это не точный размер изображения символа, а область, которую браузер принимает в расчет для построения высоты и ширины строки. Увидеть прямоугольник font-size очень легко - достаточно в браузере выделить один символ (см. пример)

line-height - это высота строки, включая высоту прямоугольника font-size. Т.е. при значениях line-height больше чем font-size к высоте прямоугольника добавляется равные высоты сверху и снизу. Можно задать значение line-height равное или даже меньше font-size , но это визуально выглядит очень плохо - строки могут накладываться одна на другую.

Важный практический вопрос - как узнать высоту, которую браузер добавит к font-size при заданном значении line-height?
Ответ простой - из line-height вычесть значение font-size.
Например, если line-height: 64px, а font-size: 50px, то браузер добавит 64px - 50px = 14px.
Еще более важный практический вопрос - как узнать высоту, которую браузер добавит сверху над прямоугольником font-size (или снизу - под прямоугольником)?
Например, если line-height: 64px, а font-size: 50px, то сверху, т.е. над прямоугольником font-size окажется высота, равная (64px - 50px) / 2 = 7px. И точно такая же высота (64px - 50px) / 2 = 7px окажется снизу под прямоугольником.
Внимание
line-height обычно задается в безразмерном виде, т.к. значение line-height наследуется. Т.е. если задать значение line-height в абсолютных величинах (`px` например), то при смене размера шрифта, можно получить неожиданные значения межстрочного интервала.
Если известно font-size и значение line-height в px, то вычислить безразмерное значение для line-height очень легко. Это значение равно отношению line-height к font-size.
Например если line-height: 64px, а font-size: 50px, то line-height = 64 / 50 = 1.28.
Задание
Для font-size со значением 18px требуется отступ под строкой и над строкой по 9px. Задай элементу p свойство line-height в безразмерном виде.-->

<p>Свойство CSS line-height устанавливает величину пространства между строками, например в тексте. </p>

p {line-height: 2;}

<!--5.Текст: вертикальное выравнивание - top
Теория
Глиф(визуальный символ) формирует прямоугольник content area. Высота content area задается font-size, ширина - определяется шрифтом.
base-line - линия, относительно которой размещается глиф внутри content area.
base-line - линия вертикального выравнивания по умолчанию для текста с font-size любого размера.
base-line - линия вертикального выравнивания по умолчанию для элементов с display: inline-block.
Вертикальное выравнивание можно переопределить, задав другую линию выравнивания. Например vertical-align: top выровняет content area по верхней границе (см. рисунок).

Задание
Измени вертикальное расположение текста и блоков со свойством display: inline-block согласно расположению на рисунке.
 -->

<div class="boxes">
    <div class="box">t</div>
    <div class="box box-48">o</div>
    <div class="box box-72">p</div>
</div>
<div class="cards">
    <div class="card"></div>
    <div class="card card-48"></div>
    <div class="card card-72"></div>
</div>
<div class="letter">
    top
</div>

.boxes,
.cards,
.letter {
font-size: 36px;
height: 100px;
padding: 1rem;
background-color: goldenrod;
margin-bottom: 1rem;
}

.box-48 { font-size: 48px; }

.box-72 { font-size: 72px; }

.card {
height: 36px;
width: 18px;
}

.card-48 {
height: 48px;
width: 36px;
}

.card-72 {
height: 72px;
width: 48px;
}

/* Напиши код под этой строкой */
.box,
.card {
display: inline-block;
vertical-align: top;
background-color: blueviolet;

}

.letter::first-letter {
vertical-align: top;
font-size: 72px;
}

<!--6.Текст: вертикальное выравнивание - middle
Теория
Вертикальное выравнивание можно переопределить, задав другую линию выравнивания. Например vertical-align: middle выровняет content area по середине высоты font-size (см. рисунок).

Задание
Измени вертикальное расположение текста и блоков со свойством display: inline-block согласно расположению на рисунке.
-->

<div class="boxes">
    <div class="box">m</div>
    <div class="box box-48">i</div>
    <div class="box box-72">d</div>
    <div class="box box-48">d</div>
    <div class="box">l</div>
    <div class="box box-48">e</div>
</div>
<div class="cards">
    <div class="card"></div>
    <div class="card card-48"></div>
    <div class="card card-72"></div>
    <div class="card card-48"></div>
    <div class="card"></div>
    <div class="card card-48"></div>
</div>
<div class="letter">
    middle
</div>

.boxes,
.cards,
.letter {
font-size: 36px;
height: 100px;
padding: 1rem;
background-color: goldenrod;
margin-bottom: 1rem;
}

.box-48 { font-size: 48px; }

.box-72 { font-size: 72px; }

.card {
height: 36px;
width: 18px;
}

.card-48 {
height: 48px;
width: 36px;
}

.card-72 {
height: 72px;
width: 48px;
}

/* Напиши код под этой строкой */
.box,
.card {
display: inline-block;
vertical-align: middle;
background-color: blueviolet;

}

.letter::first-letter {
vertical-align: middle;
font-size: 72px;

<!--7.Текст: вертикальное выравнивание - bottom
Теория
Вертикальное выравнивание можно переопределить, задав другую линию выравнивания. Например vertical-align: bottom выровняет content area по верхней границе (см. рисунок).

Задание
Измени вертикальное расположение текста и блоков со свойством display: inline-block согласно расположению на рисунке.
-->

<div class="boxes">
    <div class="box">b</div>
    <div class="box box-48">o</div>
    <div class="box box-72">t</div>
    <div class="box box-48">t</div>
    <div class="box">o</div>
    <div class="box box-48">m</div>
</div>
<div class="cards">
    <div class="card"></div>
    <div class="card card-48"></div>
    <div class="card card-72"></div>
    <div class="card card-48"></div>
    <div class="card"></div>
    <div class="card card-48"></div>
</div>
<div class="letter">
    bottom
</div>
.boxes,
.cards,
.letter {
font-size: 36px;
height: 100px;
padding: 1rem;
background-color: goldenrod;
margin-bottom: 1rem;
}

.box-48 { font-size: 48px; }

.box-72 { font-size: 72px; }

.card {
height: 36px;
width: 18px;
}

.card-48 {
height: 48px;
width: 36px;
}

.card-72 {
height: 72px;
width: 48px;
}

/* Напиши код под этой строкой */
.card {
display: inline-block;
vertical-align: bottom;
background-color: blueviolet;

}

.letter::first-letter {
vertical-align: bottom;
font-size: 72px;

}
<!--8.Текст: преобразование регистра text-transform
Теория
Регистр отображения букв в браузере можно изменить с помощью css. Для этого используется свойство text-transform со значениями
none
uppercase
lowercase
capitalize
Это свойство наследуется.
Внимание
Если в макете текст использует `uppercase` или `capitalize` то обязательно задайте этому элементу это значение, 
не полагаясь на то что вы напишите в `html`. В `html` могут вносить правки и изменить регистр, и только `css` свойство 
может гарантировать что регистр будет отображаться так, как предусмотрено в макете.
Задание
Задай или измени свойство text-transform. Значение возьмите из значения аргумента data-transform в коде html.
Обратите внимание на то, что значение применится к тексту из элемента span.
-->
<div>
    <div data-transform="none"><span>NoNe</span></div>
    <div data-transform="uppercase"><span>uppercase</span></div>
    <div data-transform="lowercase"><span>LOWERCASE</span></div>
    <div data-transform="capitalize"><span>capitalize</span></div>
</div>

[data-transform="none"] {
text-transform: none;
}

[data-transform="uppercase"] {
text-transform: uppercase;
}

[data-transform="lowercase"] {
text-transform: lowercase;
}

[data-transform="capitalize"] {
text-transform: capitalize;
}

<!--9.Текст: оформление текста text-decoration
Текст можно декорировать линиями с помощью свойства text-decoration

Положение линии относительно текста задается значениями

none
underline
overline
line-through
Стиль линии задается значениями

solid
wavy
dotted
dashed
double
Также можно задавать ширину линии (в задаче эта возможность не используется).

Свойство text-decoration не наследуется, но применятся ко всему блоку.

Задание
Найдите элементы с классом в html коде и селектор с тем же классом в css коде.
Для каждого такого элемента html перенесите значения из аргументов data-line, data-style и data-color в качестве значений для свойства text-decoration.
Для селектора с классом no перезапишите значение text-decoration с помощью значения из data-line.-->

<div>
    <div class="up" data-line="overline" data-style="wavy" data-color="red">
        <span>Overline</span>
    </div>
    <div class="through" data-line="line-through" data-style="dashed" data-color="green">
        <span>Line-through</span>
    </div>
    <div class="down" data-line="underline" data-style="solid" data-color="blue">
        <span>Underline</span>
    </div>
    <div class="no" data-line="none">
        <span>None</span>
    </div>
    <div class="combi" data-line="underline overline" data-style="double" data-color="grey">
        <span>Combination</span>
    </div>
</div>

body {
font-size: 36px;
padding: 1rem;
}

/* Напиши код под этой строкой */
.up {
text-decoration: overline wavy
red;
}
.through {

text-decoration: line-through dashed
green;
}
.down {
text-decoration: underline solid blue;
}
.no {
text-decoration: none;
}
.combi {
text-decoration: underline overline double grey;
}

<!--10.Текст: тень для текста с помощью свойства text-shadow
text-shadow: смещение X | смещение Y | радиус размытия тени | цвет

Задание
Для элемента li с классом one задай тень для текста. Для этого в коде html у элемента li с классом one найди атрибуты data. И задай в css коде селектору класса one свойство text-shadow со значениями:
смещение X (по горизонтали) взятое из значения атрибута data-x
смещение Y (по вертикали) взятое из значения атрибута data-y
blur (размытие) взятое из значения атрибута data-blur
color (цвет) взятое из значения атрибута data-color
Для элемента li с классом rings задай 4 тени разного цвета для буквы O. Селектору rings уже задано свойство text-shadow состоящее из 4 теней на разном расстоянии. Для того, чтобы задать цвет, в коде html у элемента li с классом one найди атрибут data-colors. Добавь эти цвета к значениям свойства text-shadow селектора rings согласно синтаксису для этого свойства (т.е. цвет должен быть в конце перчисления - перед запятой или точкой с запятой). Порядок цветов показан на рисунке:
'Олимпийские кольца'-->

<ol>
    <li class="one" data-x="3px" data-y="3px" data-blur="2px" data-color="hsla(0, 0%, 0%, .5)">
        CSS-свойство text-shadow добавляет тени к тексту и всем элементам text-decoration.
    </li>
    <li>К одному тексту можно применить несколько теней:
        <span class="rings" data-colors="blue black red green">O</span>
    </li>
</ol>

body {
font-family: sans-serif;
font-size: 36px;
padding: 1rem;
}
/* offset-x | offset-y | blur-radius | color */
.one {
color: blue;
text-decoration: underline wavy;
margin-bottom: 1rem;
text-shadow: 3px 3px 2px hsla(0, 0%, 0%, .5);
}
.rings {
color: orange;
text-shadow: -15px -8px 0 blue,
14px -8px 0 black,
29px 0 0 green,
44px -8px 0 red;
}

<!--11.Текст: word-spacing (расстояния между словами)
Расстояния между словами определяется двумя свойствами:

word-spacing со значениями:
normal. Соответствует числу 0, фактически же равна ширине пробела или 1/4 размера шрифта (это расстояние не зaдoкyмeнтиpoвaно стандартом, но в большинстве случаев именно так и есть );
inherit. Значение получает от родительского элемента;
любое числовое значение в любых единицах измерения css (px, rem, em и т.п.). Отрицательные значения уменьшают расстояние, положительные - увеличивают.
text-align: justify (используется редко)
Задание
В коде html элемент ol с классом items содержит несколько потомков - элементы li c разными атрибутами. В коде css всем элементам, потомкам элемента с классом items задано расстояние между словами в 1rem.

Для двух элементов li с классом item-less и item-normal необходимо переопределить это расстояние c новыми значениями, взятыми из атрибутов data-wordspacing. Для этого:

создай два css правила с селекторами класса item-less и item-normal
задай свойству word-spacing значения, взятые из значений data-wordspacing элемента, имеющего в html тот же класс, что и селектор.
Обрати внимание на наследование свойства word-spacing.-->

<ol class="items">
    <li class="item item-less" data-wordspacing="-.25rem">
        1rem соответсвует размеру шрифта, заданному в body, а .25rem равна 1/4 размера шрифта и ширине пробела между
        словами
    </li>
    <li class="item">
        <p>CSS-свойство word-spacing наследуется</p>
    </li>
    <li class="item item-normal" data-wordspacing="normal">
        <p>CSS-свойство word-spacing устанавливает длину пробела между словами и между тегами. </p>
    </li>
</ol>

.items {
word-spacing: 1rem;
}
/* Напиши код под этой строкой */

.item-less {
word-spacing: -.25rem;}

.item-normal {word-spacing: normal;}

<!--12.Текст: расстояния между буквами
Расстояния между буквами определяется двумя способами:

letter-spacing со значениями
normal. Соответствует числу 0.
inherit. Значение получает от родительского элемента.
любое числовое значение в любых единицах измерения css (px, rem, em и т.п.). Отрицательные значения уменьшают расстояние, положительные - увеличивают.
Сочетанием text-align: justify вместе с word-spacing: normal
Задание
В коде html элемент ol с классом items содержит несколько потомков - элементы li c разными атрибутами. В коде css всем элементам, потомкам элемента с классом items задано расстояние между буквами в .25rem.

Задай классам item-less и item-normal свойство letter-spacing.
Значения для свойства letter-spacing возьми из значения атрибута data-letterspacing
Обрати внимание на наследование этого свойства.-->

<ol class="items">
    <li class="item item-less" data-letterspacing="-.1rem">
        Свойство letter-spacing определяет межбуквенное расстояние в тексте.
    </li>
    <li class="item">
        <p>CSS свойство letter-spacing наследуется.</p>
    </li>
    <li class="item item-normal" data-letterspacing="normal">
        В отличие от значения 0, ключевое слово normal позволяет браузеру изменить расстояние между буквами для
        выравнивания текста.
    </li>
</ol>

.items {
letter-spacing: .25rem;
}
/* Напиши код под этой строкой */
.item-less {letter-spacing: -.1rem;}
.item-normal {letter-spacing: normal;}


5.блок.

<!--Блочная модель. Прямоугольник content box
Понимание механики блочной модели является базой для понимания того, как элементы размещаются на веб-странице. Большинство проблем в верстке возникает из-за неверного использования правил блочной модели.

В основе всего лежит content box - прямоугольная область в которой размещается контент (текст, изображения и т.п.)

Для описания геометрии прямоугольника браузер использует всего два свойства - width и height. В некоторых случаях разработчик может изменять значения этих свойств - например если значением display является block или inline-block. В других случая изменить значения width и height, заданные браузером нельзя - например если значением display является inline.

Следует запомнить три правила, которые необходимо вспоминать при изменении размещения элемента на странице с помощью css:

Значение высоты (height) для любых элементов браузер вычисляет на основе высоты контента.
Значение ширины (width) для элементов со значениями display равными inline или inline-block вычисляет на основе ширины контента.
Значение ширины (width) для элементов со значением display равным block равно 100% ширины (width) родительского элемента.
При размещении блоков content box действует особая "гравитация" - все элементы стремятся "упасть" вверх в левый угол.

Точкой отсчета для построения прямоугольника content box является верхний левый угол.

Внимание
Размещать блочные элементы внутри строчных запрещено.

Задание
Задай элементу с классом child ширину, равную половине ширины родительского элемента.

Обрати внимание на разное поведение блочных и строчных элементов при изменении значения ширины в css правиле.-->

<div class="parent">
    <div class="child">У любого элемента высота задается по контенту.
    </div>
    <div class="child">У блочных элементов потомок занимает 100% ширины родительского элемента. 
    </div> 
      <div class="child">У блочных элементов можно задать размер контентной области - изменить width или height.
    </div> 
  </div>
  <span class="parent">
    <i class="child">У любого элемента высота задается по контенту.
    </i>
    <i class="child">У строчных элементов ширина задается по контенту.
    </i>  
        <i class="child">У строчных элементов нельзя задать размер контентной области - изменить width или height.
    </i> 
  </span>

  .parent {
    background: teal;
    margin-bottom: 1rem;
  }
  
  .child {
    background: salmon;
    width: 50%;
  }
  <!--Блочная модель: min-width
У блочных элементов контент может превышать заданные размеры content-area. Предотвратить уменьшение ширины меньше минимального размера поможет свойство min-width.

Ширина элемента не уменьшится меньше значения min-width, даже если значение width будет меньше. Если контента больше, то значение min-height позволяет высоте увеличиваться.

Задание
Задай элементу с классом child минимальную ширину, равную 200px.

Обрати внимание на разное поведение блочных и строчных элементов при изменении значения ширины в css правиле.-->
  <div class="parent">
    <div class="child">У блочных элементов контент может превышать заданные размеры content-area. 
    </div> 
    <div class="child">Ширина элемента не уменьшится меньше значения min-width, даже если значение width будет меньше.
    </div>
  </div>
  <span class="parent">
    <i class="child">У любого элемента высота задается по контенту.
    </i>
    <i class="child">У строчных элементов ширина задается по контенту.
    </i>  
    <i class="child">У строчных элементов нельзя задать размер контентной области - изменить width или height.
    </i> 
  </span>

  .parent {
    background: teal;
    margin-bottom: 1rem;
  }
  
  .child {
    width: 2%;
    min-width: 200px;
    background: salmon;
  }

  <!--Блочная модель: max-width
У блочных элементов по умолчанию ширина принимает значение 100% ширины родителя. Если есть необходимость ограничить максимальную ширину элемента каким-то значением, следует использовать свойство max-width.

Ширина элемента не превысит значения max-width, даже если значение width будет больше.

Задание
Задай элементу с классом child максимальную ширину, равную 200px.

Обрати внимание на разное поведение блочных и строчных элементов при изменении значения ширины в css правиле.-->

<div class="parent">
    <div class="child">Ширина элемента не превысит значения max-width, даже если значение width будет больше.
    </div>
  </div>
  <span class="parent">
    <i class="child">У любого элемента высота задается по контенту.
    </i>
    <i class="child">У строчных элементов ширина задается по контенту.
    </i>  
    <i class="child">У строчных элементов нельзя задать размер контентной области - изменить width или height.
    </i> 
  </span>
  .parent {
    background: teal;
    margin-bottom: 1rem;
  }
  
  .child {
    width: 90%;
    background: salmon;
    max-width: 200px;
  }
  <!--Блочная модель: min-height
У любого элемента высота задается по контенту. Если контента нет, то высота равна 0. Если есть необходимость задать минимальную высоту, используйте min-height.

Высота элемента не уменьшится меньше значения min-height, даже если значение height будет меньше.

Свойство margin позволяет задавать расстояние между соседними элементами. Это свойство состоит из четырех более простых свойств по сторонам элемента

margin-top (верхняя сторона элемента)
margin-right (правая сторона элемента)
margin-bottom (нижняя сторона элемента)
margin-left (левая сторона элемента)
Задание
Задай элементу с классом parent

минимальную высоту, равную 30px;
отступ на нижней стороне элемента в 1rem (отступ от соседнего элемента).
Обрати внимание на отсутствие на веб-странице элемента с высотой 0 и его появление при задании значения свойству min-height.-->
  
<div class="parent">
    <div class="child"></div>
  </div>
  <div class="parent">
    <div class="child">
      У любого элемента высота задается по контенту. Если контента нет, то высота равна 0. Если контента больше, то значение min-height позволяет высоте увеличиваться.</div>
  </div>
.parent {
    background: teal;
    min-height: 30px;
    margin-bottom: 1rem;
  }
  
  .child {
    background: salmon;
  }
  <!--Блочная модель: height vs min-height
Если задана высота, а контента больше, чем может вместить content box, то контент выйдет за пределы элемента и перекроет элементы, расположенные ниже.

Значения min-height в подобной ситуации увеличит высоту до необходимого значения, сдвинув элементы, расположенные ниже. Таким образом в большинстве случаев min-height предпочтительнее height.

Задание
Замени значение height на min-height у элемента с классом card.

Обрати внимание на то как min-height исправил ситуацию с переполнением контента.-->
<div class="card">
    <h4 clacc="card-title">Canvas</h4>
    <p class="card-description">
      В макете psd есть область, называемая canvas. Это область в которой дизайнер может что-то рисовать, а вне этой области программа рисовать не позволит. Ширина canvas - это не конкретная ширина экрана, а максимальная. Т.е. реальный экран может быть и больше или меньше - это не важно. В верстке это все равно ширина body, которую мы не задем. Потому что ширину body задает операционная система и браузер.
    </p>
  </div>
  <div class="card">
    <h4 clacc="card-title">Content box</h4>
    <p class="card-description">Для верстки важна максимальная ширина, внутри которой размещен контент. Обычно эту ширину ограничивают направляющие.</p>
  </div>
  .card {
    background: teal;
    width: 200px;
    min-height: 300px;
  }
  <!--Блочная модель: padding и переопределение box-sizing
Свойство padding, как правило, используется для того, чтобы сместить content box и находящийся внутри контент от краев элемента. Это создает более эстетичный вид - подобно тому как в книгах, журналах или газетах контент (текст и фото) всегда расположены на некотором расстоянии от края листа.

Однако добавление padding (как и добавление border) изменяет геометрию блока, т.к. по умолчанию эти значения добавляются к размерам content box - т.е. добавляются к width или height.

Чтобы ширина блока оставалась как на макете, можно задать свойству box-sizing значение border-box. В этом случае значения вычитаются из размеров content box - т.е. width или height уменьшатся.

Уменьшение width или height может создать проблему для размещения контента при заданной ширине. Поэтому вместо height можно увеличить высоту задав свойство min-height.

Задание
Измени css свойства родительского элемента (элемента с классом parent) так, чтобы появились отступы от края до элемента-потомка, но ширина родительского элемента при этом осталась прежней. Для этого:

С помощью padding задай отступы в 1rem. Для описания значения padding используй самую короткую запись из одного значения.

Убедись, что геометрия (ширина) элемента с классом parent увеличилась на 2rem (за счет добавления ширины padding). Верни общую ширину блока к начальному значению, уменьшив content box с помощью изменения значения свойства box-sizing.

Перестал вмещаться контент? Замени у родителя и потомка свойство height на min-height.-->

<div class="parent">
    <div class="child">
    </div>
  </div>
  .parent {
    width: 200px;
    min-height: 150px;
    padding: 1rem;
    background-color: teal;
    box-sizing: border-box;
    
  }
  
  .child {
    min-height: 150px;
    background-color: goldenrod;
  }
  <!--Блочная модель: проценты
нельзя задать значение в процентах только для border;
для padding и margin процент берется только от значения width вне зависимости от того какой из сторон задается значение;
width берет проценты от ширины родительской width;
height берет проценты от ширины родительской height.
Задание
Для элемента с классом child задайте с помощью процентов
ширину в половину от ширины родительского элемента;
высоту в половину от ширины родительского элемента;
padding-left в процентах (чтобы получился эквивалент 20px);
margin-top в процентах (чтобы получился эквивалент 40px).
Т.к. высота в процентах отсчитывается только от заданной высоты, то замени свойство min-height у элемента с классом parent на свойство height.-->

<div class="parent">
    <div class="child">
      <div class="inner">w100+h150</div>
    </div>
  </div>
  .parent {
    width: 200px;
    height: 300px;
    background-color: teal;
    box-sizing: border-box;
  }
  
  .child {
    border: 1px solid #fff;
    background-color: goldenrod;
    width: 50%;
    height: 50%;
    padding-left: 10%;
    margin-top: 20%
    
  }
  
  .inner {
    background: red;
    height: 100%;
  }

  <!--Блочная модель: один из способов избежать выпадения вертикального отступа
Выпадение вертикального отступа происходит тогда, когда margin-top потомка превышает margin-top родительского элемента. В результате происходит смещение вниз как потомка, так и родителя.

Существует несколько способов избежать этого. В этом задании мы рассмотрим самый простой, но, из-за лишнего кода и изменения геометрии блоков, этот способ не является рекомендуемым.

Задание
Для элемента с классом parent задай верхнюю границу в 1px стиля solid прозрачного (transparent) цвета.

Убедитесь, что выпадение вертикального отступа исчезло.-->
<div class="parent">
    <div class="child">
      <div class="inner">w100+h150</div>
    </div>
  </div>
  .parent {
    width: 200px;
    height: 300px;
    background-color: teal;
    box-sizing: border-box;
    border-top: 1px solid transparent;
  }
  
  .child {
    width: 50%;
    height: 50%;
    border: 1px solid #fff;
    padding-left: 10%;
    margin-top: 20%;
    background-color: goldenrod;
  }
  .inner {
    background: red;
    height: 100%;
  }

  <!--Блочная модель: рекомендуемый способ избегать выпадения вертикального отступа и margin-collapse
Выпадение вертикального отступа и margin-collaps можно предотвратить, если придерживаться следующей тактики присваивания padding и margin:

родительскому элементу задавать padding вместо того, чтобы задавать дочернему элементу margin;
родительскому элементу не задавать margin-top, но задавать margin-bottom верхнему соседу.
Задание
Для элемента с классом child
удали свойство margin-top;
добавь свойство padding-top со значением 40px родительскому элементу.
Для элемента с классом parent добавь нижний отступ в 20px.

Обрати внимание, что никаких побочных эффектов от применения вертикальных значений margin не наблюдается.-->
<div class="parent">
    <div class="child">
    </div>
  </div>
  <div class="parent">
    <div class="child">
    </div>
  </div>
  .parent {
    width: 200px;
    height: 300px;
    background-color: teal;
    box-sizing: border-box;
    padding-top: 40px;
    margin-bottom: 20px;
  }
  
  .child {
    width: 50%;
    height: 50%;
    border: 1px solid #fff;
    
    margin-left: auto;
    margin-right: auto;
    background-color: goldenrod;
  }
<!--Блочная модель: display: inline-block
inline-block это

ширина по контенту;
можно задавать width и height ;
нет обязательного переноса на новую строку.
Особенность inline-block состоит в том, что браузер рассматривает такие блоки как шрифт.

Это проявляется в первую очередь в том, что к этим элементам применяются css свойства для текста вроде text-align.

Еще одно неочевидное последствие рассмотрения inline-block как шрифта, состоит в появлении неожиданных символов пробелов, которые мешают правильно рассчитать размеры блоков.

Откуда появляются пробелы?

Каждая строка li начинается с новой строки, т.е. перед <li> находится знак переноса и пробелы.

<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>  
Браузер преобразует эти символы в символ пробела размером в 1/4 размера шрифта (как правило, но может быть больше или меньше в зависимости от шрифта).

Избавиться от этих пробелов можно разными способами. Один из них это изменение html, что делает текст html нечитабельным:

перед li нет ни пробелов, ни знаков переноса

<ul><li>1</li><li>2</li><li>3</li></ul>  
Еще один способ состоит в том, чтобы задать шрифту родительского элемента размер 0. Тогда оставшиеся пробелы получат ширину 0/4 , т.е. 0. Важно не забыть снова задать размер шрифта тексту внутри inline-block.

Попрактикуемся использовать второй прием.

Задание
Добейся размещения по 4 элемента с классом box в один ряд. Для этого

измени font-size элементу с классом container;
задай font-size элементу с классом box, со значением 1rem (это значение font-size задано body).
-->  

<div class="container">
    <div class="box">1</div>
    <div class="box">2</div>
    <div class="box">3</div>
    <div class="box">4</div>
    <div class="box">5</div>
    <div class="box">6</div>
    <div class="box">7</div>
    <div class="box">8</div>
    <div class="box">9</div>
    <div class="box">10</div>
    <div class="box">11</div>
    <div class="box">12</div>
  </div>
  body {
    font-size: 20px;
  }
  /* 
    ширина container 360  
    или 4 раза по 90  
  */
  .container {
    font-size: 0;
    width: 360px;
    margin: auto;
    padding-top: 15px;
    background: burlywood;
  }
  
  /* 
    ширина box 15 + 60 + 15
    или 90  
  */
  .box {
    font-size: 1rem;
    width: 60px;
    margin: 0 15px 15px;
    height: 75px;
    line-height: 75px;
    background-color: teal;
    display: inline-block;
    text-align: center;
    color: #fff;
  }
<!--Блочная модель: display: inline-block
Практикуемся делать расчеты для отступов между блоками.

Задание
Добейся размещения по 3 элемента с классом box в один ряд с расстоянием от края в 15px и расстоянием между соседними элементами в 30px. Для этого задай одно свойство margin со значениями

0 для верхнего отступа (его заменяет padding-top родителя);
15px для нижнего отступа;
15px для левого и правого отступа.-->  
<div class="container">
    <div class="box">1</div>
    <div class="box">2</div>
    <div class="box">3</div>
    <div class="box">4</div>
    <div class="box">5</div>
    <div class="box">6</div>
    <div class="box">7</div>
    <div class="box">8</div>
    <div class="box">9</div>
    <div class="box">10</div>
    <div class="box">11</div>
    <div class="box">12</div>
  </div>
  body {
    font-size: 20px;
  }
  /* 
    ширина container 480  
    или 3 раза по 160  
  */
  .container {
    padding-top: 0;
    width: 480px;
    margin: auto;
    padding-top: 15px;
    background: burlywood;
    font-size: 0;
  }
  
  /* 
    ширина box x + 130 + x
    или 160  
  */
  .box {
    margin: 0 15px 15px;
    width: 130px;
    height: 75px;
    line-height: 75px;
    background-color: teal;
    display: inline-block;
    text-align: center;
    color: #fff;
    font-size: 1rem;
  }

  <!--12. Псевдокласс nth-of-type() и nth-last-of-type
Еще одна модель размещения блоков. На этот раз у родительского элемента задан padding на все 4 стороны.

Задание
Добейся размещения по 3 элемента с классом box в один ряд с расстоянием от края в 0 и расстоянием между соседними элементами в 30px (сумма margin-left и margin-right). Для этого задай

margin-left: 0 для 1-го, 4-го, 7-го и 10-го элемента;
margin-right: 0 для 3-го, 6-го, 9-го и 12-го элемента;
margin-bottom: 0 для 10-го, 11-го и 12-го элемента.-->

<div class="container">
    <div class="box">1</div>
    <div class="box">2</div>
    <div class="box">3</div>
    <div class="box">4</div>
    <div class="box">5</div>
    <div class="box">6</div>
    <div class="box">7</div>
    <div class="box">8</div>
    <div class="box">9</div>
    <div class="box">10</div>
    <div class="box">11</div>
    <div class="box">12</div>
  </div>
  body {
    font-size: 20px;
  }
  
  /* 
    2 * 15 - это размер, 
    который box-sizing: border-box 
    отнял у width и height
  
    ширина container 480  - (2 * 15)
    или 3 раза по 160 - (2 * 15)  
  */
  .container {
    width: 480px;
    margin: auto;
    padding: 15px;
    background: burlywood;
    font-size: 0;
    box-sizing: border-box;
  }
  
  /* 
    ширина box x + 130 + x
    или 160  
    за исключением крайних элементов
  */
  .box {
    width: 130px;
    margin: 0 15px 15px;
    height: 75px;
    line-height: 75px;
    background-color: teal;
    display: inline-block;
    text-align: center;
    color: #fff;
    font-size: 20px;
  }
  
  .box:nth-of-type(3n+1) {
    margin-left: 0;
  }
  
  .box:nth-of-type(3n) {
    margin-right: 0;
  }
  
  .box:nth-last-of-type(-n+3) {
    margin-bottom: 0;
  }

  6. блок

  <!--Flex
Основные термины flex модели
Flex значительно упрощает верстку, но требует взамен

наличия контейнера, чтобы задать display: flex и потомков, чтобы к ним применились свойства и значения Flexbox Layout;
умение расположить потомков вдоль главной оси с помощью свойства justify-content. Можно расположить равномерно от края до края (space-between) или по центру (center) и другими способами;
умение расположить потомков вдоль вспомогательной оси с помощью свойства align-items, например по центру ;
и другие свойства, которые не рассматриваются в этой задаче.
Задание
Добейся размещения 3-х элементов с классом box в один ряд с расстоянием между соседними элементами в 30px без использования margin. Для этого задай элементу с классом container свойства с подходящими значениями
display для того чтобы flex модель применилась к потомкам;
justify-content для добавления равных отступов между блоками.
Размести текст (цифру) по центру элемента с классом box. Для этого задай элементу с классом box подходящие значения свойствам
display для того чтобы flex модель применилась к потомку - тексту;
justify-content для центрирования по горизонтали ;
align-items для центрирования по вертикали.-->

<div class="container">
    <div class="box">1</div>
    <div class="box">2</div>
    <div class="box">3</div>
  </div>
  body {
    font-size: 20px;
  }
  
  /* 
    2 * 15 - это размер, 
    который box-sizing: border-box 
    отнял у width и height
  
    ширина container 480  - (2 * 15)
    или 3 раза по 160 - (2 * 15)  
  */
  .container {
    display: flex;
    justify-content: space-between;
    width: 480px;
    margin: auto;
    padding: 15px;
    background: burlywood;
    box-sizing: border-box;
  }
  
  .box {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 130px;
    min-height: 75px;
    background-color: teal;
    color: #fff;
  }
<!--Flex: justify-content
Свойство justify-content позволяет размещать элементы вдоль главной оси.

Задание
У элемента с классом container padding-left и padding-right равны 0.

Добейся размещения 3-х элементов с классом box в один ряд с расстоянием между соседними элементами в 30px и по 15px по краям, без использования margin.

Для этого задай элементу с классом container подходящее значение для свойства justify-content.-->  
<div class="container">
    <div class="box">1</div>
    <div class="box">2</div>
    <div class="box">3</div>
  </div>
  body {
    font-size: 20px;
  }
  
  /* 
    ширина container 480 
    или 3 раза по 160   
  */
  .container {
    justify-content: space-around;
    width: 480px;
    margin: auto;
    padding: 15px 0;
    background: burlywood;
    box-sizing: border-box;
    display: flex;
  }
  
  .box {
    width: 130px;
    min-height: 75px;
    background-color: teal;
    color: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  <!--Flex
Перенос потомков на новую строку

Flex стремиться разместить все элементы-потомки вдоль главной оси. Для этого модель Flex может изменять размеры прямых потомков. Если необходимо сохранить размеры и позволить перенос потомков на новую строку, то необходимо применить свойство flex-wrap со значением wrap - перенос.

Задание
Добейся размещения по 3 элемента классом box в один ряд с расстоянием между соседними элементами в 30px без использования margin. И с нижним отступом в 15px.
Для этого задай

элементу с классом container свойство flex-wrap со значением для переноса потомков на новую строку;
элементу с классом box свойство margin-bottom со значением отступа.
Обрати внимание, что у элемента с классом container значение свойства padding в 15px применятся к трем сторонам и не применятся к padding-bottom.-->

<div class="container">
    <div class="box">1</div>
    <div class="box">2</div>
    <div class="box">3</div>
    <div class="box">4</div>
    <div class="box">5</div>
    <div class="box">6</div>
    <div class="box">7</div>
    <div class="box">8</div>
    <div class="box">9</div>
    <div class="box">10</div>
    <div class="box">11</div>
    <div class="box">12</div>
  </div>
 
  body {
    font-size: 20px;
  }
  
  .container {
    flex-wrap: wrap;
    width: 480px;
    margin: auto;
    padding: 15px 15px 0;
    background: burlywood;
    box-sizing: border-box;
    display: flex;
    justify-content: space-between;
  }
  
  .box {
    margin-bottom: 15px;
    width: 130px;
    min-height: 75px;
    background-color: teal;
    color: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
  }
<!--Flex
Вложение контейнера flex внутри другого контейнера flex

Любому потомку, находящемуся под действием свойства flex родительского элемента можно также задать свойство flex. Этот прием можно применять для размещения сложных конструкций, вроде логотипа и навигационного меню.

Попробуем использовать такое вложение на практике.

Задание
Добейся размещения в один ряд элементов внутри header. При этом элемент logo должен быть в левом углу, а меню - в правом.
Для этого задай элементу с классом container

display для того чтобы flex модель применилась к потомкам;
свойство justify-content для размещения элементов по краям родительского элемента;
свойство align-items для центрирования элементов по вертикали;
элементу с классом nav-menu  задай свойство display для того, чтобы flex модель применилась к потомкам.-->  

<header class="container">
    <div class="logo">
      <a href="#"><img src="./images/logo.png" alt="logo" width="50"/></a>
    </div>
    <ul class="nav-menu">
      <li class="nav-menu_item">
        <a href="#" class="nav-menu_link">link1</a>
      </li>
      <li class="nav-menu_item">
        <a href="#" class="nav-menu_link">link2</a>
      </li>
      <li class="nav-menu_item">
        <a href="#" class="nav-menu_link">link3</a>
      </li>
    </ul>
  </header>
  a {
    text-decoration: none;
  }
  
  .container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    max-width: 480px;
    margin: auto;
    padding: 15px;
    background: burlywood;
    box-sizing: border-box;
  }
  
  .nav-menu {
    display: flex;
    list-style: none;
  }
  
  .nav-menu_link {
    margin: 0 15px;
  }
  <!--Flex
Изменение положения одного элемента вопреки значению justify-content

Для того чтобы изменить положение для одного элемента (или определенной группы элементов), находящегося под действием свойства justify-content используют подходящее свойство margin-left или margin-right со значением auto.

Задание
Добейся размещения элемента с классом box-left в левом углу, не меняя положения элементов, расположенных в правом углу.
Для этого задай элементу с классом box-left подходящее свойство margin с нужным значением.-->

<ul class="container">
    <div class="box box-left">left</div>
    <div class="box box-right">right 1</div>
    <div class="box box-right">right 2</div>
  </ul>
  body {
    font-size: 20px;
  }
  
  /* 
    ширина container 480 
    или 3 раза по 160   
  */
  .container {
    width: 90%;
    margin: auto;
    padding: 15px 0;
    background: burlywood;
    box-sizing: border-box;
    display: flex;
    justify-content: flex-end;
  }
  
  .box {
    width: 130px;
    min-height: 75px;
    background-color: teal;
    color: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 0 15px
  }
  
  .box-left {
    margin-right: auto;
  
  }














  Block 9
  <!--Position - элементы вне потока.
Значения свойства position:

static значение по умолчанию для всех элементов
relative
absolute
fixed
sticky
Все position, со значением отличным от static - вне потока выполнения.

Элементы вне потока создают новый контекст, т.е. потомки этих элементов перемещаются совместно с родителем.

Свойства, связанные с position

top
right
bottom
left
z-index
отсчет и направления
Задание
Элемент с классом box надо переместить вниз и вправо на 50%. Для этого

измени свойство position на absolute;
задай начало отсчета и направление с помощью свойств left и top со значением в 50%;
Убедись что

смещение происходит относительно левого верхнего угла элемента, т.к. именно он попадает в заданную точку - центр прямоугольника;
при смещении элемента, вместе с ним перемещаются его потомки: элемент span и текст.-->

<div class="container">
  <div class="box">
    <span>x</span>
  </div>
</div>

.container {
  width: 480px;
  height: 240px;
  margin: 1rem auto;
  background: 
  /* верхний фон */
  linear-gradient(26.3deg, 
  /* черный прозрачностью .2 */
    hsla(0, 0%, 0%, .2), 
    hsla(0, 0%, 0%, .2) 50%, 
    transparent 50%, 
    transparent),
    /* нижний фон */
  linear-gradient(153.3deg,
    teal, 
    teal 50%, 
    slategray 50%, 
    slategray);
  position: relative;
}

.box {
  --size: 50px;
  width: var(--size);
  height: var(--size);
  background-color: orange;
  display: flex;
  /* Напиши код под этой строкой */
	position: absolute;
  left: 50%;
  top: 50%;
  
}

/*
  центрируем элемент при
  родителе под flex
 */
span {
  margin: auto;
}

<!--2.Position: relative vs margin.
У элемента с position: relative границы элемента в потоке сохраняются, но сам элемент приподнимается над потоком и может перемещаться с помощью свойств: top, right, bottom и left.

Элемент с position: relative не перемещает соседние элементы на новое место, в отличие от перемещения с помощью margin.

Задание
Для двух элементов, расположенных среди других элементов, задайте смещение вниз и вправо на 2rem. Для этого:

Для элемента с классом by-position задайте свойство position: relative и затем осуществите смещение свойствами top и left.

Для элемента с классом by-margin осуществите смещение свойствами margin-top и margin-left.

Убедись, что элемент со свойством position: relative при смещении не изменил положение соседних элементов.-->

<div class="container-fluid">
  <section>
    <h2>Инлайн блоки</h2>
    <div class="container">
      <div class="box">1</div>
      <div class="box">2</div>
      <div class="box">3</div>
    </div>
    <div class="container">
      <div class="box">4</div>
      <div class="box by-margin">margin</div>
      <div class="box">6</div>
    </div>
    <div class="container">
      <div class="box">7</div>
      <div class="box">8</div>
      <div class="box">9</div>
    </div>
  </section>
  <section>
    <h2>Инлайн блоки</h2>
    <div class="container">
      <div class="box">1</div>
      <div class="box">2</div>
      <div class="box">3</div>
    </div>
    <div class="container">
      <div class="box">4</div>
      <div class="box by-position">relative</div>
      <div class="box">6</div>
    </div>
    <div class="container">
      <div class="box">7</div>
      <div class="box">8</div>
      <div class="box">9</div>
    </div>
  </section>
</div>
body {
  font-family: sans-serif;
}
h2 {
  text-align: center;
}
.container-fluid {
  display: flex;
  justify-content: space-between;
}
.container {
  width: 350px;
  margin: .5rem auto;
  padding: .75rem .5rem .25rem;
  border-radius: 1rem;
  background-color: teal;

  /* удаляем пробелы между inline-block */
  font-size: 0;
}
.box {
  display: inline-block;
  width: 100px;
  margin: 0 .5rem .5rem;
  border-radius: .5rem;
  color: #fff;
  background-color: orange;

  /* восстанавливаем видимость текста */
  font-size: 18px;
  
  /* центрируем текст */
  --h: 2rem;
  height: var(--h);
  line-height: var(--h);
  text-align: center;
}

/* Напиши код под этой строкой */
.by-position {
  background-color: palevioletred;
  position: relative;
  top: 2rem;
  left: 2rem;

}
.by-margin {
  background-color: lightskyblue;
margin-top: 2rem;
  margin-left: 2rem;}

  <!--3.Position: relative vs margin 2.0
Если задать элементу margin для всех четырех сторон, то будут применены все 4-ре значения.

Для элементов с position: relative и position: absolute смещение происходит совсем не так.

У свойства top преимущество top над bottom

У свойства left преимущество left над right

Именно это факт отражен на изображении - для свойств top и left задан жирный шрифт.

отсчет и направления
Давайте убедимся в этой особенности сами.

Задание
Для двух элементов, расположенных среди других элементов, задайте смещение на 2rem на все 4-ре стороны. Для этого:

Для элемента с классом by-position задайте свойство position: relative и затем осуществите смещение свойствами top, left, bottom и right.

Для элемента с классом by-margin осуществите смещение свойством margin и значением 2rem.

Убедись, что элемент со свойством position: relative при смещении проигнорировал значения bottom и right.-->
<div class="container-fluid">
  <section>
    <h2>Flex</h2>
    <div class="container display-flex">
      <div class="box">1</div>
      <div class="box">2</div>
      <div class="box">3</div>
    </div>
    <div class="container display-flex">
      <div class="box">4</div>
      <div class="box by-margin">margin</div>
      <div class="box">6</div>
    </div>
    <div class="container display-flex">
      <div class="box">7</div>
      <div class="box">8</div>
      <div class="box">9</div>
    </div>
  </section>
  <section>
    <h2>Flex</h2>
    <div class="container display-flex">
      <div class="box">1</div>
      <div class="box">2</div>
      <div class="box">3</div>
    </div>
    <div class="container display-flex">
      <div class="box">4</div>
      <div class="box  by-position">relative</div>
      <div class="box">6</div>
    </div>
    <div class="container display-flex">
      <div class="box">7</div>
      <div class="box">8</div>
      <div class="box">9</div>
    </div>
  </section>
</div>
body {
  font-family: sans-serif;
}
h2 {
  text-align: center;
}
.container-fluid {
  display: flex;
  justify-content: space-between;
}
.container {
  width: 350px;
  margin: .5rem auto;
  padding: .75rem .5rem .25rem;
  border-radius: 1rem;
  background-color: teal;
  display: flex;
  justify-content: space-around;
  flex-wrap: wrap;
}
.box {
  width: 100px;
  margin: 0 .5rem .5rem;
  border-radius: .5rem;
  color: #fff;
  background-color: orange;
  font-size: 18px;
  
  /* центрируем текст */
  --h: 2rem;
  height: var(--h);
  line-height: var(--h);
  text-align: center;
}

.by-position {
  background-color: palevioletred;
position: relative;
  top: 2rem;
  left: 2rem;
  bottom: 2rem;
  right: 2rem;
}
.by-margin {
  background-color: lightskyblue;
margin: 2rem;
}

<!--4.Position: fixed.
Аналог position: absolute.

Отличие в том, что у fixed есть только один предок, относительно которого можно размещать элемент - это viewport.

Viewport это область просмотра браузера (или окно браузера, за исключением панелей и границ самого окна).

Скролл окна браузера не может изменить положение элемента fixed

При выводе страницы на печать элемент fixed будет распечатан на каждом листе страницы документа.

Задание
В html коде есть элементы с атрибутом id и значениями up и down. На каждый такой элемент создана ссылка - с классом up и якорем href="#up", и классом down и якорем href="#down". Эти ссылки используются для навигации по странице - перехода к элементам с соответствующим id по клику на ссылку.

Размести ссылки так, чтобы при вертикальной прокрутке окна браузера ссылки оставались неподвижными на своих местах (одна - в верхнем, вторая - в нижнем углу в 3rem от краев).

Для этого:

элементу с классом up задай свойства top и left со значением 3rem;
элементу с классом down задай свойства bottom и right со значением 3rem;
элементу с классом page-nav задай свойства position с подходящим значением.-->
<header id="up">
  <h2>Header</h2>
</header>
<main></main>
<footer id="down">
  <h2>Footer</h2>
</footer>
<a href="#up"
 class="page-nav up">
  &#11014;
</a>
<a href="#down"
 class="page-nav down">
  &#11015;
</a>
:root {
  --s: 50px;
}

body {
  font-size: 24px;
  text-align: center;
  font-family: sans-serif;
  background: linear-gradient(hsl(189, 100%, 85%), hsl(224, 75%, 25%));
}

main {
 height: 200vh;
}

footer {
  color: #fff
}

a {
  width: var(--s);
  height: var(--s);
  line-height: var(--s);
  text-decoration: none;
  font-size: 36px;
  display: inline-block;
  color: #fff;
  border-radius: 1rem;
  background-color: firebrick;
}

/* Напиши код под этой строкой */
.page-nav {
position: fixed;
}

.up {
top: 3rem;
  left: 3rem;
}

.down {
bottom: 3rem;
  right: 3rem;
}
<!--5.Position: fixed. Модальное окно.
vh и vw
Viewport или область просмотра браузера точно равна окну браузера. Точнее viewport равен размерам внутренней части окна браузера, за исключением панелей и границ самого окна.

Viewport не является частью HTML, поэтому вы не можете влиять на него CSS-правилами. Однако мы можем устанавливать размер элементов HTML относительно размера viewport.

1vh - единица, равная 1/100-ой высоты viewport;
1vw - единица, равная 1/100-ой ширины viewport.
Размещение элемента по центру его родителя с помощью position
Как мы уже видели, смещение на 50% с помощью top и left приведет к тому что в центре элемента окажется верхний левый угол. Если нам известна ширина и высота самого элемента, то мы можем переместить верхний левый угол с помощью отрицательных margin-left и margin-top вверх и влево.

Если значение margin-left будет половина от ширины, а значение margin-top будет половина от высоты, то при отрицательном смещении центр элемента окажется там, где был верхний левый угол этого элемента.

Таким образом, совмещая top: 50%; left: 50% со сдвигом отрицательного margin-left и margin-top в половину ширины и высоты, мы расположим элемент строго по центру родительского элемента.

Модальное окно
Этот термин используют для описания эффекта, когда веб-страницу затемняют и делают недоступной для кликов или выделения текста. А по центру экрана располагается окно с каким-то важным содержимым - текст с кнопкой или форма для заполнения и кнопкой закрытия модального окна.

Рассмотрим базовые приемы для создания модального окна.

Задание
Элемент с классом modal надо разместить на всю ширину и высоту экрана с темным полупрозрачным фоном. По центру этого элемента надо разместить другой элемент с классом box. Для этого элементу с классом modal:

Удали у свойства display значение none. Это разместит modal в DOM и браузер начнет применять css свойства.

Добавь свойству display значение flex. Тогда потомок - элемент с классом box имея значение margin: auto будет находиться по центру родительского элемента.

Задай черный полупрозрачный цвет фону с помощью background-color: hsla(0, 0%, 0%, .5);.

Задай свойство position и значение fixed.

Растяни элемент на всю ширину экрана, задав свойствам left, rigth, top и bootom значение 0.

Отцентрируй элемент с селектором класса box, задав свойство margin со значением auto. Обрати внимание, что если элемент находится под действием родительского свойства flex, то свойство auto выравнивает не только по ширине, но и по высоте родительского элемента.

Обрати внимание на то что ссылка находится под элементом с классом modal и в результате стала недоступной для клика.-->

<a href="https://developer.mozilla.org/ru/docs/Learn/CSS/CSS_layout/Positioning"
   target="_blank"
   rel="noopener noreferrer">
    Переход к разделу документации: "Позиционирование"
</a>
<div class="modal">
    <div class="box">
        <p>Пример размещения модального окна.</p>
        <button class="btn">Ok</button>
    </div>
</div>
body {
  height: 200vh;
  background: linear-gradient(hsl(189, 100%, 85%), hsl(224, 75%, 25%));
  text-align: center;
}

.box {
  padding: 2rem 1rem;
  box-sizing: border-box;
  width: 360px;
  height: 200px;
  background-color: #fff;
  cursor: initial;
/* Добавь свойство под этой строкой */
margin: auto;
}

.btn,
.box {
  cursor: pointer;
  
}

.modal {
  cursor: not-allowed;
/* Измени код под этой строкой */
  display: flex;
background-color: hsla(0, 0%, 0%, .5);
  position: fixed;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  
}

<!--6.Position: sticky.
Неподвижный header
Техника неподвижный header основана на том CSS правиле position: fixed, что и при создании модального окна. Но в технике неподвижный header используется ряд отличий:

не задается значение свойству bottom;
элементу задается высота;
элементу задается z-index больше, чем у других элементов, например больше чем у элементов с position: sticky.
Sticky (липкий)
Значение sticky свойства position:

соединяет поведение элементов при значениях fixed и absolute;
поддерживает только свойство top, т.е. не поддерживается bottom, left и right;
свойство top требует обязательно задать начальное значение (например 0).
Задание
Есть несколько списков с названиями тегов. У каждого списка первым элементом идет li с классом letter и текстом, содержащим букву, с которой начинается теги в этом списке. Надо сделать так, чтобы при прокрутке списков вниз буква каждого списка прижималась к header и оставалась в таком положении до тех пор, пока теги из этого списка видны на экране.

Для этого элементам с классом letter:

добавь свойство position со значением sticky;
задай обязательное начальное значение top по высоте header (т.е. 40px);
убедись в том что элементы с классом letter при некоторых условиях ведут себя как position со значением fixed.-->

<header>
  <h1>Sticky</h1>
</header>
<div class="container">
  <main>
      <h2>HTML tags</h2>
      <ul>
          <li class="letter">A</li>
          <li>a</li>
          <li>abbr</li>
          <li>address</li>
          <li>area</li>
          <li>article</li>
          <li>aside</li>
          <li>audio</li>
      </ul>
      <ul>
          <li class="letter">B</li>
          <li>b</li>
          <li>base</li>
          <li>bdi</li>
          <li>bdo</li>
          <li>blockquote</li>
          <li>body</li>
          <li>button</li>
      </ul>
      <ul>
          <li class="letter">C</li>
          <li>canvas</li>
          <li>caption</li>
          <li>cite</li>
          <li>code</li>
          <li>col</li>
          <li>colgroup</li>
      </ul>
      <ul>
          <li class="letter">D</li>
          <li>data</li>
          <li>datalist</li>
          <li>dd</li>
          <li>del</li>
          <li>details</li>
          <li>dfn</li>
          <li>div</li>
          <li>dl</li>
          <li>dt</li>
      </ul>
      <ul>
          <li class="letter">E</li>
          <li>em</li>
          <li>embed</li>
      </ul>
      <ul>
          <li class="letter">F</li>
          <li>fieldset</li>
          <li>figcaption</li>
          <li>figure</li>
          <li>footer</li>
          <li>form</li>
      </ul>
      <ul>
          <li class="letter">H</li>
          <li>h1 - h6</li>
          <li>head</li>
          <li>header</li>
          <li>hr</li>
          <li>html</li>
      </ul>
      <ul>
          <li class="letter">I</li>
          <li>i</li>
          <li>iframe</li>
          <li>img</li>
          <li>input</li>
          <li>ins</li>
      </ul>
      <ul>
          <li class="letter">K</li>
          <li>kbd</li>
      </ul>
      <ul>
          <li class="letter">L</li>
          <li>label</li>
          <li>legend</li>
          <li>li</li>
          <li>link</li>
      </ul>
      <ul>
          <li class="letter">M</li>
          <li>main</li>
          <li>map</li>
          <li>mark</li>
          <li>meta</li>
          <li>meter</li>
      </ul>
      <ul>
          <li class="letter">N</li>
          <li>nav</li>
          <li>noscript</li>
      </ul>
      <ul>
          <li class="letter">O</li>
          <li>object</li>
          <li>ol</li>
          <li>optgroup</li>
          <li>option</li>
          <li>output</li>
      </ul>
      <ul>
          <li class="letter">P</li>
          <li>p</li>
          <li>param</li>
          <li>picture</li>
          <li>pre</li>
          <li>progress</li>
      </ul>
      <ul>
          <li class="letter">Q</li>
          <li>q</li>
      </ul>
      <ul>
          <li class="letter">R</li>
          <li>rb</li>
          <li>rp</li>
          <li>rt</li>
          <li>rtc</li>
          <li>ruby</li>
      </ul>
      <ul>
          <li class="letter">S</li>
          <li>s</li>
          <li>samp</li>
          <li>script</li>
          <li>section</li>
          <li>select</li>
          <li>slot</li>
          <li>small</li>
          <li>source</li>
          <li>span</li>
          <li>strong</li>
          <li>style</li>
          <li>sub</li>
          <li>summary</li>
          <li>sup</li>
      </ul>
      <ul>
          <li class="letter">T</li>
          <li>table</li>
          <li>tbody</li>
          <li>td</li>
          <li>template</li>
          <li>textarea</li>
          <li>tfoot</li>
          <li>th</li>
          <li>thead</li>
          <li>time</li>
          <li>title</li>
          <li>tr</li>
          <li>track</li>
      </ul>
      <ul>
          <li class="letter">U</li>
          <li>u</li>
          <li>ul</li>
      </ul>
      <ul>
          <li class="letter">V</li>
          <li>var</li>
          <li>video</li>
      </ul>
      <ul>
          <li class="letter">W</li>
          <li>wbr</li>
      </ul>
  </main>
</div>
.container {
  padding-top: 40px;
  width: 480px;
  margin: auto;
}

header {
  display: flex;
  margin: 0;
  font-family: sans-serif;
  background-color: #fff;
  box-shadow: 2px 2px 6px 3px hsla(0, 0%, 0%, .2);

/* Неподвижный header */
  position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 40px;
    z-index: 20;
}

h1 {
  margin: auto;
}

.letter {
  height: 2rem;
  margin-left: 10rem;
  margin-right: 10rem;
  border-radius: 3px;
  list-style-type: none;
  line-height: 2rem;
  text-align: center;
  color: #d00;
  background: navajowhite;
  /* Напиши код под этой строкой */
position: sticky;
  top: 40px;
}

<!--7.Absolute
Положение элемента с position: absolute
Если не заданы top, right, bottom или left, то элемент занимает верхний левый угол контентной области родителя (т.е. такой элемент будет учитывать padding или border ближайшего родительского элемента).

Если какое-то значение из top, right, bottom или left задано, то от сторон ближайшего предка с position отличным от static (элемент не будет учитывать padding или border).

Если нет предков с position, отличным от static, то отсчет ведется от body.

Относительные размеры у элементов с position: absolute
Размеры элемента с position: absolute, заданные в относительных единицах зависят от контекста (от размеров ближайшего relative элемента).

Задание
Задай элементам с классом box свойство top со значением 0 и убедись в том что элементы нашли ближайшего предка с position: relative или body и расположились в нем как в родительском элементе.

Задай элементам с классом box свойство width со значением 100%
и убедись в том что элементы заняли всю ширину своего нового родительского элемента с position: relative или body .-->

<div class="container-outer psr">
  <div class="container">
      <div class="box">2</div>
  </div>
</div>
<div class="container-outer">
  <div class="container psr">
      <div class="box">3</div>
  </div>
</div>
<div class="box">1</div>
:root {
  --s: 1.5rem;
}
* {
  margin: 0;
  padding: 0;
}
body {
  padding-top: 1rem;
}
.container-outer {
  margin: 1rem 0 0;
  padding: .5rem 0;
  width: 75%;
  background-color: mediumseagreen;
}
.container {
  background-color: slateblue;
  padding: .5rem 0;
  width: 50%;
  height: var(--s);
}
.psr {
  position: relative;
}
.box {
  border-radius: 2rem;
  height: var(--s);
  line-height: var(--s);
  background-color: crimson;
  text-align: center;
  position: absolute;
  /* Напиши код под этой строкой */
top: 0;
  width: 100%;
}
<!--8.z-index
z-index изменяет положение элемента по оси Z, где ось Z - линия перпендикулярная экрану монитора.

Значение z-index по умолчанию не задано (условно равно 0) для всех элементов.

Для свойства z-index допустимы отрицательные значения.

Запомнить:
z-index действует на соседей.
z-index не действует на потомков.
Задание
Надо изменить порядок отображения элементов по оси, перпендикулярной экрану монитора. При этом надо убедиться, что z-index не действует на потомков.

Для этого:

Элементу с классом inner задай свойство z-index: 100 и убедись, что эти элементы не перекрываются никакими другими элементами (т.к. у всех остальных элементов значение z-index не задано).

Расположите элементы с классом alfa, beta и gamma в таком порядке

alfa выше всех соседей, со значением 30 свойства z-index;
beta находится по средине, со значением 20 свойства z-index;
gamma ниже всех соседей, со значением 10 свойства z-index.
Убедитесь, что элементы с классом inner теперь частично перекрыты, т.е. z-index не действует на потомков.-->

<div class="box alfa">
  <div class="inner"></div>
</div>
<div class="box beta">
  <div class="inner"></div>
</div>
<div class="box gamma">
  <div class="inner"></div>
</div>
.box {
  display: flex;
  --s: 60px;
  width: var(--s);
  height: var(--s);
  border-radius: 50%;
  position: absolute;
}
.inner {
  margin: auto;
  --s: 30px;
  width: var(--s);
  height: var(--s);
  border-radius: 50%;
  background-color: orange;
z-index: 100;
}
.alfa {
  background-color: crimson;
  top:30px;
  left: 5px;
z-index: 30;
}
.beta {
  background-color: slateblue;
  left: 25px;
z-index: 20;
}
.gamma {
  top:30px;
  left: 45px;
  background-color: mediumseagreen;
z-index: 10;
}

Block 10.

<!--1.2D трансформации: центрирование.
Смещение
Функция transalate(tx, ty) перемещает элемент в горизонтальном (ось X) и вертикальном (ось Y) направлениях относительно начального положения.

Отрицательные значения X смещают элемент влево.
Отрицательные значения Y смещают элемент вверх.
Значение в процентах вычисляет проценты от размера самого элемента.

Задание
Элемент с классом box надо разместить по центру родительского элемента. Для этого используй смещение на 50%, с помощью свойства position, со значением absolute, а также свойство transform со значением translate и смещением по горизонтали и вертикали в -50%;-->
<div class="container">
  <div class="box">
    <span>x</span>
  </div>
</div>
.container {
  width: 480px;
  height: 240px;
  margin: 16px auto;
  background:
  /* верхний фон */
  linear-gradient(26.3deg,
  /* черный прозрачностью .2 */
    hsla(0, 0%, 0%, .2),
    hsla(0, 0%, 0%, .2) 50%,
    transparent 50%,
    transparent),
    /* нижний фон */
  linear-gradient(153.3deg,
    teal,
    teal 50%,
    slategray 50%,
    slategray);
  position: relative;
}

.box {
  --size: 50px;
  width: var(--size);
  height: var(--size);
  background-color: orange;
  display: flex;
  /* Напиши код под этой строкой */
position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

/*
  центрируем элемент при
  родителе под flex
 */
span {
  margin: auto;
}
<!--2.Симметричность CSS переходов при событии hover
Событие hover принято оформлять какими-то изменениями CSS свойств. При использовании CSS переходов для hover очень важно размещать свойства в подходящих селекторах.

Дело в том, что если разместить все связанное с CSS переходами только в селекторе с псевдоклассом hover, то при наведении курсора, CSS переходы будут работать как ожидается. Но когда курсор покинет элемент, CSS переход не сработает.

Рассмотрим задачу, которая покажет, как избегать подобной ситуации.

Задание
Наведи курсор на элемент (красный круг) и убедись что при hover CSS переход есть.
Уведи курсор от элемента и убедись, что CSS переход не работает при отводе курсора.
Сделай CSS переход симметричным, т.е. чтобы переход происходил как при наведении курсора на элемент, так и при отводе курсора с элемента. Для этого:

перемести строку transition: .8s all ease; из селектора .box:hover  в селектор .box;
убедись что после перемещения CSS переход симметричен относительно события hover.-->
<h4>Симметричность CSS перехода при <em>hover</em></h4>
<div class="border">
  <div class="box"></div>
</div>
body {
  text-align: center;
  font-family: sans-serif;
}

.box {
  display: inline-block;
  --r: 90px;
  width: var(--r);
  height: var(--r);
  border-radius: 50%;
  background: crimson;
  cursor: pointer;
/* Измени код под этой строкой */
  transition: .8s all ease;
}

.box:hover {
  
  border-radius: 0;
  background: slateblue;
}
<!--3.CSS переход при событии hover и приоритет свойства left над right
Рассмотрим пример как создать разное поведение CSS перехода при наведении и при отводе курсора от элемента. Для этого можно использовать, к примеру, факт преимущества свойства left над свойством right у элементов с position: absolute.

Рассмотрим ситуацию, когда к одному и тому же элементу применяются одновременно два свойства left и right. В примере ниже для элементов с классами left и right применяются одноименные свойства. А для элемента с классом both применяются left и right одновременно. Бросается в глаза тот факт что свойство left имеет преимущество, несмотря на то, что оно в потоке выполнения записано раньше чем свойство right.

<div class="container">
  <div class="box left"></div>
  <div class="box right"></div>
</div>
<div class="container">
  <div class="box both"></div>
</div>

.container {
  max-width: 480px;
  margin: 1rem auto;
  min-height: 20px;
  padding: 1rem;
  box-shadow: 2px 2px 6px 3px hsla(0, 0%, 0%, .2);
  position: relative;
}
.box {
  --s: 20px;
  width: var(--s);
  height: var(--s);
  position: absolute;
  top: 1rem;
}
.left {
  background-color: crimson;
  left: 1rem;
}
.right {
  background-color: slateblue;
  right: 1rem;
}
.both {
  background-color: teal;
  left: 1rem;
  right: 1rem;
}
Если мы повысим специфичность для свойства right, добавив в селектор еще один класс с псевдоклассом :hover , все равно преимущество left сохранится, как видно в пример ниже. При наведении курсора на элемент container одновременно срабатывают два свойства left и right. В разных контейнерах специфичность селектора выше то у одного свойства, то у другого, но итоговый результат одинаковый и определяется преимуществом left над right.

<div class="container">
  <div class="box first"></div>
</div>
<div class="container">
  <div class="box second"></div>
</div>
.container {
  max-width: 480px;
  margin: 1rem auto;
  min-height: 20px;
  padding: 1rem;
  box-shadow: 2px 2px 6px 3px hsla(0, 0%, 0%, .2);
  position: relative;
}
.box {
  --s: 20px;
  width: var(--s);
  height: var(--s);
  position: absolute;
  top: 1rem;
}
.first {
  background-color: crimson;
  left: 1rem;
}
.second {
  background-color: slateblue;
  right: 1rem;
}
.container:hover .first {
  right: 1rem;
}
.container:hover .second {
  left: 1rem;
}
Эту особенность можно использовать в CSS переходах с использованием hover.

Задание
При наведении курсора на текст ссылки происходит CSS переход (подчеркивание). CSS переход начинается и заканчивается с левой стороны как при наведении, так и при отводе курсора. Сделай так, чтобы CSS переход начинался с левой стороны при наведении, но при отводе курсора заканчивался с правой стороны.

Для этого расставь свойства left и right со значением 0 в подходящих селекторах.-->
<ul>
  <li><a href="#">item </a></li>
  <li><a href="#">item</a></li>
  <li><a href="#">item </a></li>
</ul>
ul {
  display: flex;
  list-style: none;
}
li {
  margin: 0 1rem;
  position: relative;
}

a {
  display: block;
  padding-bottom: 10px;
  text-align: center;
  text-transform: uppercase;
  text-decoration: none;
  font-family: sans-serif;
  color: #f38181;
  
}
a::after {
  content:"";
  width: 0;
  height: 2px;
  position: absolute;
  bottom: 0;
  
  background: #f38181;
  transition: width .5s, left .5s;
  right: 0;
}

a:hover::after {
  width: 100%;
  left: 0;
  
}
<!--4.CSS анимации при загрузке страницы
Довольно часто, при открытии страницы, это событие сопровождается анимацией. Рассмотрим пример организации кода с примером такой анимации.

Задание
В html для элементов с классом row заданы классы с описанием двух анимаций. В css коде селекторам с классом анимации задано свойство animation-name с соответствующим значением из описания анимации @keyframes fadeInFromLeft и @keyframes fadeInFromRight.

В перечислении селекторов .fadeInFromLeft, .fadeInFromRight записаны неверные свойства анимации.

Измените эти значения на:

1000ms для длительности анимации;
1 для количества повторов анимации;
both для определения когда (в начале или конце) будет применен первый и последний фрейм из анимации;
ease-in-out для описания функции времени у анимации;
500ms для задержки начала анимации.
Убедитесь в выполнении анимации после ввода верных значений - для этого кликните на иконку в правом углу (см. на фото)иконка для всплывающего окнаАнимация должна выполнится только один раз.-->
<div class="container">
  <div class="row fadeInFromLeft"></div>
  <div class="row fadeInFromRight"></div>
  <div class="row fadeInFromLeft"></div>
  <div class="row fadeInFromRight"></div>
</div>
.container {
  max-width: 480px;
  min-height: 100vh;
  margin: auto;
  padding: 1rem;
  box-shadow: 2px 2px 6px 3px hsla(0, 0%, 0%, .2);
}
.row {
  margin-bottom: 1rem;
  min-height: 60px;
}
.row:nth-of-type(2n) {
  background-color: crimson;
}
.row:nth-of-type(2n + 1) {
  background-color: slateblue;
}


@keyframes fadeInFromLeft {
  0% {
    transform: translateX(-2000px) scale(0.6);
    opacity: 0.7;
  }
  80% {
    transform: translateX(50px) scale(0.7);
    opacity: 0.7;
  }
  to {
    transform: translateX(0) scale(1);
    opacity: 1;
  }
}
@keyframes fadeInFromRight {
  0% {
    transform: translateX(2000px) scale(0.6);
    opacity: 0.7;
  }
  80% {
    transform: translateX(-50px) scale(0.7);
    opacity: 0.7;
  }
  to {
    transform: translateX(0) scale(1);
    opacity: 1;
  }
}

.fadeInFromLeft,
.fadeInFromRight  {
  animation-duration: 1000ms;
  animation-iteration-count: 1;
  animation-fill-mode: both;
  animation-timing-function: ease-in-out;
  animation-delay: 500ms;
}
.fadeInFromLeft {
  animation-name: fadeInFromLeft;
}
.fadeInFromRight {
  animation-name: fadeInFromRight;
}
<!--5.Симметричность анимации при событии hover
В отличие от CSS переходов правильно задать анимацию при hover намного проще. Для этого надо написать вызов анимации в селекторе элемента и отдельно в селекторе элемента с псевдоклассом hover. Важно лишь то, что это должны быть анимации с разными именами (или одним именем, если начальное и конечное состояние совпадают).

Задание
Начальное состояние элемента - круг с цветом crimson. При hover элемент должен стать квадратом с цветом slateblue.

Есть две анимации, описывающие изменение CSS свойств при наведении курсора (cursorMoveIn) и при отводе курсора от элемента (cursorMoveOut).

Задайте краткую форму вызова анимации animation: name 0.8s forwards; в разных селекторах, заменив name на подходящее имя анимации.-->
<h4 class="title">
  Анимация при <em>hover</em>
</h4>
  <div class="box">
</div>
body {
  text-align: center;
  font-family: sans-serif;
}

@keyframes  cursorMoveOut {
  from {
    border-radius: 50%;
    background: crimson;
  }
  to {
    border-radius: 0;
    background: slateblue;
  }
}
@keyframes cursorMoveIn {
  from {
    border-radius: 0;
    background: slateblue;
  }
  to {
    border-radius: 50%;
    background: crimson;
  }
}

.box {
  display: inline-block;
  --r: 90px;
  width: var(--r);
  height: var(--r);
  border-radius: 50%;
  background: crimson;
  cursor: pointer;
  /* Напиши код под этой строкой */
animation: cursorMoveIn 0.8s forwards;
}

.box:hover {
animation: cursorMoveOut 0.8s forwards;
}

Block 11.

<!--1.Формы: атрибуты input
Браузер считывает у элемента input значение атрибута type и определяет, что именно будет введено пользователем - текст, пароль, цвет, число, дата и т.п.

То, что вводит пользователь, становится значением атрибута value. И для того, чтобы отличать value одного элемента input от другого, браузер использует атрибут name.

Можно сказать, что атрибуты type и name - обязательные атрибуты.
Атрибут value добавляет сам браузер на основе полученных от пользователя данных. И хотя начальное value можно задать, на практике это неудобно, т.к. приходится удалять начальное значение.

Если для пользователя необходимо показать какой-то текст, который будет автоматически удален с вводом первого символа, то для этого в элемент input можно добавить атрибут placeholder с нужным значением.

Задание
В редакторе html есть элемент input. Задайте этому элементу три атрибута со своими значениями:

атрибут type и значение text;
атрибут name и значение login;
атрибут placeholder и значение Введите логин:.-->

<input type="text" name="login" placeholder="Введите логин:" />
* {
box-sizing: border-box;
}
input {
height: 2.5rem;
width: 28rem;
padding: 1rem .75rem;
border: 1px solid hsla(0, 0%, 13%, 0.2);
border-radius: .25rem;
outline: none;
}

<!--2.2. Формы: label
Иногда удобно (особенно для радиокнопок и чекбоксов) иметь текст, при клике по которому, input получит эффект фокуса. Для этого используют элемент label.

<form>
  <label>красный 
    <input type="radio" name="color" value="red">
  </label>
  <label>зеленый 
    <input type="radio" name="color" value="green">
  </label>
  <label>синий 
    <input type="radio" name="color" value="blue">
  </label>
</form>
label:first-of-type { color: red; }
label:nth-of-type(2) { color: green; }
label:last-of-type { color: blue; }
Кликните по тексту для изменения фокуса на радиокнопке:

красный  зеленый  синий 
В примере выше текст находился слева от input. Но положение текста легко изменить, переместив текст справа от input.

<form>
  <label> 
    <input type="radio" name="color" value="red">
    красный
  </label>
  <label> 
    <input type="radio" name="color" value="green">
    зеленый
  </label>
  <label> 
    <input type="radio" name="color" value="blue">
    синий
  </label>
</form>
label:first-of-type { color: red; }
label:nth-of-type(2) { color: green; }
label:last-of-type { color: blue; }
Кликните по тексту для изменения фокуса на радиокнопке:

 красный  зеленый  синий
Приведенные два варианта - самые распространенные. Однако текст и input можно связать без вложения друг в друга. Это делается с помощью атрибута for для label и атрибута id для input с одинаковым значением.

<form>
  <label for="id-red"> 
    красный
  </label>
  <label for="id-green"> 
    зеленый
  </label>
  <label for="id-blue"> 
    синий
  </label>
<br>
  <input id="id-green" type="radio" name="color" value="green">
  <input id="id-red" type="radio" name="color" value="red">
  <input id="id-blue" type="radio" name="color" value="blue">
</form>
label[for="id-red"]{ color: red; }
label[for="id-green"] { color: green; }
label[for="id-blue"]{ color: blue; }
Кликните по тексту для изменения фокуса на радиокнопке:

красный зеленый синий
  
Задание
Перемести span так, чтобы этот элемент был слева от input. Убедись, что текст теперь отображается также слева от input.-->

<label>

  <span>Логин</span>
  <input type="text" name="login" placeholder=" " />
</label>
* {
box-sizing: border-box;
}
label {
display: block;
width: 28rem;
margin-bottom: 1.75rem;
position: relative;
}
input {
height: 2.5rem;
padding: 1rem .75rem;
border: 1px solid hsla(0, 0%, 13%, 0.2);
border-radius: .25rem;
outline: none;
}
span {
font-size: .875rem;
letter-spacing: 0.01rem;
color: #757575;
}

<!--3.Формы: form
Два правила, которые необходимо запомнить для использования элемента form:

Нельзя размещать form внутри другого элемента form.
Внутри одной веб-страницы нельзя размещать более одного элемента input вне элемента form.
Часто используемые атрибуты элемента form:

autocomplete со значением off;
method - способ отправки данных браузером (в большинстве случаев для безопасности используется значение POST).
Атрибут action используется редко. Однако на момент верстки, для того чтобы предотвратить обработку (отправку данных) браузером, для формы создают заглушку в виде
атрибута action со значением # (или javascript:void(0);). В результате браузер игнорирует нажатие кнопки type="submit".

Кнопка - элемент button или input с атрибутом type="submit".

Также иногда для сложных форм используют кнопку с атрибутом type="reset" для удаления из input всего, что было введено в пределах элемента form.

Задание
Т.к. внутри одной веб-страницы нельзя размещать более одного элемента input вне элемента form, то оберните элементы в html редакторе этим элементом.

Элементу form задайте три атрибута:

атрибут autocomplete со значением off;
атрибут method со значением POST;
атрибут action со значением javascript:void(0);.
Перед закрытием тега form вставьте элемент button с текстом Отправить и атрибутом type со значением submit.-->

<form autocomplete="off" method="POST" action="javascript:void(0);">
  <label>
    <span>Логин</span>
    <input type="text" name="login" placeholder=" " />
  </label>
  <label>
    <span>Пароль</span>
    <input type="password" name="password" placeholder=" " />
  </label>
  <button type="submit">Отправить</button>
</form>
:root {
--shadow: 0px 4px 4px hsla(0, 0%, 0%, 0.15);
--border: 1px solid hsla(0, 0%, 13%, 0.2);
--shift: transform 250ms cubic-bezier(0.4, 0, 0.2, 1);
}
* {
box-sizing: border-box;
}
form {
width: 28rem;
margin: 1rem;
padding: 2rem 1rem;
text-align: center;
box-shadow: var(--shadow);
}
label {
display: block;
margin-bottom: 1.75rem;
position: relative;
}
input {
width: 100%;
height: 2.5rem;
padding: 1rem .75rem;
border: var(--border);
border-radius: .25rem;
outline: none;
}
span {
font-size: .875rem;
letter-spacing: 0.01rem;
color: #757575;

position: absolute;
top: 50%;
left: 2.625rem;
transform: translateY(-50%);
transition: var(--shift);
}

label:focus-within > span,
input:not(:placeholder-shown) + span {
font-size: .75rem;
letter-spacing: 0.01rem;
color: #2196f3;
transform: translate(-1.5rem, -2.3rem);
}
button {
--h: 3.125rem;
height: var(--h);
line-height: var(--h);
min-width: 12.5rem;
padding: 0 2rem;
text-align: center;
font-weight: 700;
font-size: 1rem;
letter-spacing: 0.06rem;
color: #fff;
background-color: #2196f3;
box-shadow: var(--shadow);
border-style: none;
border-radius: 4px;
cursor: pointer;
transition: var(--shift);
}

<!--4.Формы: textarea
textarea - многострочное текстовое поле для сбора большого количества текста от пользователя.

Следует запомнить что:

атрибут rows устанавливает количество строк (высоту)
атрибут cols устанавливает количество колонок (ширину)
css свойство resize позволяет изменения размера элемента по
horizontal (горизонтали)
vertical (вертикали)
both (по вертикали и горизонтали)
none (не позволяет изменять размер)
При использовании placeholder у элемента textarea возможно исчезновение текста. Рассмотрим причину и способ исправления ситуации.

Задание
Из-за наличия пробельного символа между открывающим и закрывающим тегом textarea содержимое атрибута placeholder не отображается.

Удали пробелы (или переносы) между открывающим и закрывающим тегом textarea.-->

<form autocomplete="off" method="POST" action="javascript:void(0);">
  <label for="id-comment">Комментарий</label>
  <textarea id="id-comment" name="comment" placeholder="Поделись своим мнением:"></textarea>
  <button type="submit">Отправить</button>
  <button type="reset">Сброс</button>
</form>
* {
box-sizing: border-box;
}
form {
width: 28rem;
margin: 1rem;
padding: 2rem 1rem;
font-size: 1rem;
text-align: center;
box-shadow: 0px 4px 4px hsla(0, 0%, 0%, 0.15);
}
label {
width: 28rem;
display: block;
margin-bottom: 1.75rem;
position: relative;
color: #757575;
}
button {
--h: 3.125rem;
height: var(--h);
line-height: var(--h);
min-width: 12.5rem;
margin: 1rem auto;
display: block;
padding: 0 2rem;
text-align: center;
font-weight: 700;
letter-spacing: 0.08rem;
color: #fff;
box-shadow: var(--shadow);
border-style: none;
border-radius: 4px;
cursor: pointer;
transition: var(--shift);
}
button[type="submit"] {
background-color: #2196f3;
}
button[type="reset"] {
background-color: crimson;
}
textarea {
width: 100%;
height: 7.5rem;
padding: 1rem .75rem;
border: 1px solid hsla(0, 0%, 13%, 0.2);
border-radius: .25rem;
color: #757575;
outline: none;
resize: none;
}
textarea::placeholder {
color: hsl(0, 90%, 54%);
}


<!--5.Формы. Радиокнопки и чекбоксы.
Что необходимо помнить при создании радиокнопок или чекбоксов:

Набор радиокнопок или чекбоксов должны иметь одинаковые значения атрибута name.
Набор требует задавать значения атрибута value разработчиком, а не пользователем (пользователь выберет подходящее значение из предложенных).
Атрибут checked нужен, чтобы отметить выбранный элемент.
Атрибут disabled нужен, чтобы данный input нельзя было выбрать.
Стилизация радиокнопки или чекбокса стандартным способом невозможна. Существуют трюки с помощью CSS (следующее задание) или JS + CSS.

Задание
В готовой разметке html задай:

Элементам с value="black" атрибут disabled.
Элементам с value="green" атрибут checked.
Убедись что у элементов с type="radio" можно выбрать только один элемент, а у элементов с type="checkbox" - все элементы, кроме тех что имеют атрибут disabled.

Убедись, что кнопка Обновить возвращает выделение элемента с заданным атрибутом cheked.-->

<div class="container">
  <section>
    <h4>Выбери только одно значение</h4>
    <form action="javascript:void(0);" id="id-radio">
      <div>
        <label for="id-red">red</label>
        <label for="id-green">green</label>
        <label for="id-blue">blue</label>
        <label for="id-black">black</label>
      </div>
      <div>
        <input id="id-red" name="colors" type="radio" value="red" />
        <input id="id-green" name="colors" type="radio" value="green" checked />
        <input id="id-blue" name="colors" type="radio" value="blue" />
        <input id="id-black" name="colors" type="radio" value="black" disabled />
      </div>
    </form>
    <button form="id-radio" type="submit">Отправить</button>
    <button form="id-radio" type="reset">Обновить</button>
  </section>
  <section>
    <h4>Выбери несколько значений</h4>
    <form action="javascript:void(0);" id="id-checkbox">
      <div>
        <label for="red">red</label>
        <label for="green">green</label>
        <label for="blue">blue</label>
        <label for="black">black</label>
      </div>
      <div>
        <input id="red" name="colors" type="checkbox" value="red" />
        <input id="green" name="colors" type="checkbox" value="green" checked />
        <input id="blue" name="colors" type="checkbox" value="blue" />
        <input id="black" name="colors" type="checkbox" value="black" disabled />
      </div>
    </form>
    <button form="id-checkbox" type="submit">Отправить</button>
    <button form="id-checkbox" type="reset">Обновить</button>
  </section>
</div>
* {
box-sizing: border-box;
}
.container {
display: flex;
}
section {
margin: 0 2rem;
padding: 1rem;
box-shadow: 0px 4px 4px hsla(0, 0%, 0%, 0.15);
}
form {
margin: 1rem;
padding: 0 1rem;
font-size: 1rem;
display: flex;
justify-content: space-between;
}
label {
display: block;
color: #757575;
}
input {
display: block;
}
button {
--h: 2rem;
height: var(--h);
line-height: var(--h);
min-width: 10.5rem;
margin: 1rem auto;
display: block;
padding: 0 1rem;
text-align: center;
font-weight: 700;
letter-spacing: 0.08rem;
color: #fff;
border-style: none;
border-radius: 4px;
cursor: pointer;
}
button[type="submit"] {
background-color: #2196f3;
}
button[type="reset"] {
background-color: crimson;
}


<!--6.Формы: select
select - элемент с выбором опций.

option элемент списка select с данными для выбора в виде текста или значения атрибута value.

Атрибуты option (не обязательны):

value - содержит значение для выбора (если отсутствует, то значение берут из текста);
selected выделяет значение по умолчанию;
disabled делает опцию недоступной для выделения.
optgroup элемент для объединения в группы нескольких option.

Атрибут optgroup:

label - содержит описание для группы опций.
Задание
Есть список опций, которые надо разделить на три группы. Для этого оберни option элементом optgroup в таком порядке:

option с атрибутом value="frontend" должен быть обернут элементом с атрибутом label, имеющим значение Developer;

option с атрибутами value и значениями html, css и js должен быть обернут элементом с атрибутом label, имеющим значение Base skills;

option с атрибутами value и значениями vue, react и angular должен быть обернут элементом с атрибутами label, имеющим значение Frameworks и disabled.

Убедись что атрибут disabled не дает возможность выбирать значение для всех option группы.-->

<form action="javascript:void(0);">
  <select>
    <optgroup label="Developer">
      <option value="frontend">Frontend</option>
    </optgroup>

    <optgroup label="Base skills">
      <option value="html" selected>HTML</option>
      <option value="css">CSS</option>
      <option value="js">JavaScript</option>
    </optgroup>

    <optgroup label="Frameworks" disabled>
      <option value="vue">Vue</option>
      <option value="react">React + GraphQL</option>
      <option value="angular">Angular</option>
    </optgroup>

  </select>
  <button type="submit">Отправить</button>
  <button type="reset">Обновить</button>
</form>
button {
display: block;
margin: 1rem;
}

<!--7.Формы: datalist
datalist - элемент, содержащий возможные опции для выбора элемента input с атрибутом list.

datalist невидим. Но можно увидеть текст option. Для этого элемент input должен иметь атрибут list и элемент datalist должен иметь атрибут id с одинаковыми значениями.

Задание
При вводе в элемент input букв, содержащихся в названиях текста элементов option (например буквы o) должен появляться список для выбора.

Убедись, что пока такой список не появляется. Исправь это следующим образом:

элементу input добавь атрибут list со значением browsers;
элементу datalist добавь атрибут id со значением browsers.
Убедись, что при вводе букв появляется список тех option, текст которых содержит эти буквы.-->
<form action="javascript:void(0);">
  <label for="myBrowser">Выбор браузера</label>
  <input id="myBrowser" name="myBrowser" list="browsers" />
  <datalist id="browsers">
    <option>Chrome</option>
    <option>Firefox</option>
    <option>Internet Explorer</option>
    <option>Opera</option>
    <option>Safari</option>
    <option>Microsoft Edge</option>
  </datalist>
</form>

Block 12.
<!--1.Формы. Стилизация радиокнопок и чекбоксов.
При стилизации радиокнопок и чекбоксов важно задать стили для следующих состояний:

:checked для выбранного элемента;
:focus для элемента в фокусе;
:disabled для элемента, который нельзя изменить;
:checked:disabledдля выбранного элемента, который нельзя изменить;
Стилизация некоторых элементов форм не предусмотрена спецификациями и браузером. Дизайнеры со своей стороны могут предлагать изменить внешний вид. В таком случае можно использовать некоторую технику, позволяющую обойти ограничения.

Для радиокнопок и чекбоксов суть техники состоит в том чтобы

скрыть вид элемента по умолчанию;
сохранить поведение по умолчанию для элемента (изменение с помощью клавиши пробел и переход с помощью клавиши таб, например);
на месте скрытого элемента создать стилизованное изображение (стилизация с помощью фона, псевдоэлемента и т.п.).
Основная проблема состоит в том, как правильно скрыть элемент, не удалив его из DOM. Это важно, для того чтобы сохранить поведение по умолчанию.

Самый простой способ скрыть вид элемента элемент по умолчанию
это использование свойства appearance со значением none. Этот способ не поддерживается браузером Internet Explorer и требует дополнять запись этого свойства вендорными префиксами:

.hidden {
  -moz-appearance: none;
  -webkit-appearance: none;
  appearance: none;
}
Рассмотрим пример стилизации с помощью этого способа.

Задание
Есть готовая верстка `html` и заданы стили для элементов форм. Убедись в работе элементов, а именно что можно - перемещаться с помощью клавиши `Tab` - и менять значения с помощью `Space`.
С помощью свойства appearance со значением none скрой вид элементов по умолчанию. Для этого размести запись с вендорными префиксами
-moz-appearance и -webkit-appearance перед записью appearance: none.

Убедись что стилизованные элементы ведут себя также, как и элементы по умолчанию.-->

<div class="container">
  <form>
    <label>
      <span>понедельник</span>
      <input class="custom-input hidden" type="checkbox" name="weekday" value="Mon" checked />
    </label>
    <label>
      <span>вторник</span>
      <input class="custom-input hidden" type="checkbox" name="weekday" value="Tue" />
    </label>
    <label>
      <span>среда</span>
      <input class="custom-input hidden" type="checkbox" name="weekday" value="Wed" />
    </label>
    <label>
      <span>четверг</span>
      <input class="custom-input hidden" type="checkbox" name="weekday" value="Thu" />
    </label>
    <label>
      <span>пятница</span>
      <input class="custom-input hidden" type="checkbox" name="weekday" value="Fri" />
    </label>
    <label>
      <span>суббота</span>
      <input class="custom-input hidden" type="checkbox" name="weekday" value="Sut" disabled />
    </label>
    <label>
      <span>воскресенье</span>
      <input class="custom-input hidden" type="checkbox" name="weekday" value="Sun" disabled checked />
    </label>
    <button type="reset">Отмена</button>
  </form>
  <form>
    <label>
      <span>понедельник</span>
      <input class="custom-input hidden" type="radio" name="week" value="Mo" checked />
    </label>
    <label>
      <span>вторник</span>
      <input class="custom-input hidden" type="radio" name="week" value="Tu" />
    </label>
    <label>
      <span>среда</span>
      <input class="custom-input hidden" type="radio" name="week" value="We" />
    </label>
    <label>
      <span>четверг</span>
      <input class="custom-input hidden" type="radio" name="week" value="Thu" />
    </label>
    <label>
      <span>пятница</span>
      <input class="custom-input hidden" type="radio" name="week" value="Thu" />
    </label>
    <label>
      <span>суббота</span>
      <input class="custom-input hidden" type="radio" name="weekend" value="Sut" disabled />
    </label>
    <label>
      <span>воскресенье</span>
      <input class="custom-input hidden" type="radio" name="weekend" value="Sun" disabled checked />
    </label>
    <button type="reset">Отмена</button>
  </form>
</div>

body {
--s: 20px;
font-size: var(--s);
}
.container {
display: flex;
justify-content: space-between;
max-width: 480px;
}
label {
display: flex;
justify-content: space-between;
}
.custom-input {
display: block;
width: var(--s);
height: var(--s);
background-color: crimson;
position: relative;
border: 4px solid transparent;
color: #fff;
}
.custom-input[type="radio"] {
border-radius: 50%;
}
.custom-input:checked {
background-color: seagreen;
}
.custom-input:focus {
border: 4px solid hsla(0,0%,0%,.4);
outline: none;
}
.custom-input:disabled {
background-color: lavender;
}
.custom-input:checked:disabled {
background-color: seagreen;
opacity: .5;
}
.hidden {
-moz-appearance: none;
-webkit-appearance: none;
appearance: none;
}


<!--2.Формы. Стилизация select.
После того как элемент скрыт, необходимо показать какой-то стилизованный элемент. Очень удобно использовать svg изображение. Изображение можно разместить в свойстве background-image: url() указав путь к файлу. Но можно вставить svg код напрямую, сделав необходимые преобразования.

Как сделать преобразование? Необходимо иметь готовое изображение svg и затем сделать преобразование на одном из сервисов

SVG to Data URI converter;
SVG to CSS background-image converter;
URL-encoder for SVG.
Например из svg треугольника

<svg width="16px" height="16px" viewBox="0 0 16 16" 
    version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
    preserveAspectRatio="xMidYMid">
  <g>
    <polygon points="0,0 16,0 8,16" fill="blue"/> 
  </g>
</svg> 
после преобразования можно получить такую строку:

"data:image/svg+xml;charset=UTF-8,%3csvg width='16px' height='16px' viewBox='0 0 16 16' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' preserveAspectRatio='xMidYMid'%3e%3cg%3e%3cpolygon points='0,0 16,0 8,16' fill='blue'/%3e%3c/g%3e%3c/svg%3e "
Задание
Есть готовый html и css код для стилизации select. У селектора .select-custom закомментировано свойство background-image с преобразованной строкой svg в качестве значения url и линейным градиентом.

Раскомментируй строку и убедись, что svg изображение можно вставлять inline не только в html, но и в css.-->

<form action="javascript:void(0);">
  <select class="select-custom">
    <optgroup label="Developer">
      <option value="frontend">Frontend</option>
    </optgroup>
    <optgroup label="Base skills">
      <option value="html" selected>HTML</option>
      <option value="css">CSS</option>
      <option value="js">JavaScript</option>
    </optgroup>
    <optgroup label="Frameworks" disabled>
      <option value="vue">Vue</option>
      <option value="react">React + GraphQL</option>
      <option value="angular">Angular</option>
    </optgroup>
  </select>
  <button type="submit">Отправить</button>
  <button type="reset">Обновить</button>
</form>


* {
box-sizing: border-box;
}
form {
width: 28rem;
margin: 1rem;
padding: 2rem 1rem;
font-size: 1rem;
text-align: center;
box-shadow: 0px 4px 4px hsla(0, 0%, 0%, 0.15);
}
button {
display: block;
margin: 0 auto 1rem;
}
.select-custom {

/* 1 - скрой стили по умолчанию */
-moz-appearance: none;
-webkit-appearance: none;
appearance: none;
outline: none;

/* 2 - задай размеры и положение */
display: block;
width: 100%;
max-width: 100%;
margin: 0 auto 1rem;
padding: .6em 1.4em .5em .8em;

/* оформи border */
border: 1px solid #aaa;
border-radius: .5em;

/* оформи текст */
font-size: 16px;
font-family: sans-serif;
font-weight: 700;
color: #444;
line-height: 1.3;

/* оформи тень от блока */
box-shadow: 0 1px 0 1px hsla(0, 0%, 0%, 0.04);

/* оформи фон и фоновое изображение */
background-repeat: no-repeat;
background-position: right .7rem top 50%, 0 0;
background-size: .65rem auto, 100%;

background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg width='16px' height='16px' viewBox='0 0 16 16'
version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'
preserveAspectRatio='xMidYMid'%3e%3cg%3e%3cpolygon points='0,0 16,0 8,16' fill='blue'/%3e%3c/g%3e%3c/svg%3e"),
linear-gradient(to bottom, #ffffff 0%, #e5e5e5 100%);

}

<!--3.Формы. Псевдоклассы состояний.
Задание
Задана верстка html формы и оформлены стили css. Необходимо дополнить стили оформлением элемента input для плейсхолдера и для валидного и невалидного контента. Для этого:

Для селектора псевдоэлемента input::placeholder задай цвет текста rebeccapurple;

Для селектора input:not(:placeholder-shown) с псевдоклассом

:valid  задай свойство border-color со значением seagreen;
:invalid  задай свойство border-color со значением crimson.
Обрати внимание на то как срабатывает валидация для input с атрибутом pattern=".{3,5}" - валидация происходит только если количество символов в этом элементе от 3-х до 5-ти.-->

<form action="javascript:void(0);" method="POST">
  <label>
    <span>Имя</span>
    <input type="text" name="name" placeholder="Имя" />
  </label>
  <label>
    <span>Почта</span>
    <input type="email" name="email" required placeholder="Электронная почта" />
  </label>
  <label>
    <span>Пароль</span>
    <input type="password" name="password" required placeholder="Пароль от 3 до 5 символов" pattern=".{3,5}"
      title="от 3 до 5 символов" />
  </label>
  <div class="buttons">
    <button type="submit">отправить</button>
    <button type="reset">обновить</button>
  </div>
</form>
form {
max-width: 360px;
margin: auto;
padding: 1rem 2rem 1rem 1rem;
border-radius: .25rem;
box-shadow: 2px 2px 6px 3px hsla(0, 0%, 0%, .2);
font-family: sans-serif;
text-transform: uppercase;
}
.buttons,
label {
display: flex;
justify-content: space-between;
align-items: center;
}
label {
margin-bottom: 1.5rem;
}
label span {
opacity: .6;
}
input {
border: 2px solid lavender;
padding: 4px;
border-radius: .25rem;
}
button {
padding: .5rem 1.75rem;
border-radius: .25rem;
text-transform: uppercase;
border: none;
outline: none;
opacity: .6;
background-color: gray;
color: #fff;
}
button:hover {
background-color: gray;
opacity: 1;
}

/* placeholder */
input::placeholder {
/* Напиши код под этой строкой; */
color: rebeccapurple;
}

/* focus-within */
label:focus-within span {
opacity: 1;
}
form:focus-within button[type="submit"] {
opacity: .6;
background-color: seagreen;
}
form:focus-within button[type="reset"]{
opacity: .6;
background-color: crimson;
}
form:focus-within {
box-shadow: 1px 1px 2px 2px hsla(0, 0%, 0%, .3);
}

/* valid */
form:valid button {
color: #fff;
pointer-events: none;
}

/* combination */
form:focus-within:valid button {
opacity: 1;
}
input:not(:placeholder-shown):valid {
/* Напиши код под этой строкой; */
border-color: seagreen;
}
input:not(:placeholder-shown):invalid {
/* Напиши код под этой строкой; */
border-color: crimson;
}

Block 13. BEM

<!--1.BEM. Блок.
Методология БЭМ
БЭМ - безопасное повторное использование на любой странице сайта и в любой части документа css правил для групп элементов html.

Блок
Блок, это функционально независимый компонент.

Блок выделяют из других элементов HTML с помощью создания специального имени в качестве значения атрбута class.

Имя класса для блока должно отвечать на вопросы "что это" или "для чего это".

Блоки могут быть вложены один в другой.

Пример:

<!--  Шапка сайта -->
<header class="page-header">
  <!--  Логотип -->
  <a class="logo">...</a>
...</header>

<!--  Карточка -->
<div class="card">...
  <!--  Кнопка -->
  <button class="btn">...</button>
</div>

Неверно заданные имена классов (отвечают на вопрос "какой", а не "что это" или "для чего это"):

<!--  Шапка сайта -->
<header class="header-light">
  <!--  Логотип -->
  <a class="logo-header">...</a>
...</header>

<!--  Карточка -->
<div class="card-left">
  <!--  Кнопка -->
  <button class="btn-focused">...</button>
...</div>
Задание
В коде html показаны только блоки. Удали элементы с названиями классов, которые не соответствуют методологии БЭМ (отвечают на вопрос "какой").-->

<!-- Что это? Шапка страницы/page-header -->
<header class="page-header">page-header</header>
<!-- Что это? Контейнер/container -->
<main class="container">
  <!-- Что это? Заголовок/title -->
  <h2 class="title">title</h2>
  <!-- Какой? С большими буквами/big-letters -->
  <p class="big-letters">big-letters</p>
  <!-- Что это? Статья о БЭМ/bem-article -->
  <article class="bem-article">
    <!-- Какой? Светлый заголовок/header-light -->
    <header class="header-light">header-light</header>
    <!-- Какой? Темный низ/footer-dark -->
    <footer class="footer-dark">footer-dark</footer>
  </article>
</main>
<!-- Что это? Низ страницы/page-footer -->
<footer class="page-footer">page-footer</footer>


<!-- Что это? Шапка страницы/page-header -->
<header class="page-header">page-header</header>
<!-- Что это? Контейнер/container -->
<main class="container">
  <!-- Что это? Заголовок/title -->
  <h2 class="title">title</h2>
  <!-- Какой? С большими буквами/big-letters -->

  <!-- Что это? Статья о БЭМ/bem-article -->
  <article class="bem-article">
    <!-- Какой? Светлый заголовок/header-light -->

    <!-- Какой? Темный низ/footer-dark -->

  </article>
</main>
<!-- Что это? Низ страницы/page-footer -->
<footer class="page-footer">page-footer</footer>


<!--2.BEM. Элемент.
Элемент
Элемент, это часть блока, которая не может быть использована вне самого блока.

Название элемента связано с названием блока: имя-блока__имя-элемента, т.е. состоит из трех частей:

название блока;
двойного нижнего подчеркивания;
название элемента.
Название элемента, это существительное, которое отвечает на вопрос "что это?".

Элементы блока могут быть вложены один в другой, но это никак не отражается на названии элемента.

В методологии БЭМ "элемент элемента" - это грубая ошибка в названии.

Пример:

<!--  Шапка сайта ->
<ul class="list">
  <li class="list__item">
    <a class="list__link" href="#">...</a>
  </li>
</ul>

<!--  Карточка ->
<div class="card">
  <img class="card__image" src="" alt="">
  <h4 class="card__title">...</h4>
  <p class="card__description">...</p>
</div>

<!--  Логотип ->
<a class="logo">
  <img class="logo__image" src="" alt="">
</a>

<!--  Кнопка ->
<button class="btn">
  <i class="btn__icon"></i>
  <span class="btn__message">...</span>
</button>
Неверно заданные имена элементов

отвечают на вопрос "какой",
не содержат названия блока,
или содержат название двух элементов:
<!--  Шапка сайта ->
<header class="page-header">
  <!--  Логотип ->
   <a class="logo__page-header">
     <img class="page-header__logo__image" src="" alt="">
   </a
</header>

<!--  Карточка ->
<div class="card">
  <img class="card-big__image" src="" alt="">
  <h4 class="card-big__title">...</h4>
  <p class="full__description">...</p>
</div>

<!--  Кнопка ->
<button class="btn__focused">...</button>
Задание
В коде html представлен блок authentication. Элементам этого блока необходимо задать имена классов, используя слова из списка:

label;
title;
input;
btn.->

<form class="authentication" autocomplete="off" method="POST" action="javascript:void(0);">
  <label class="authentication__label">
    <span class="authentication__title">Логин</span>
    <input class="authentication__input" type="text" name="login" placeholder=" " />
  </label>
  <label class="authentication__label">
    <span class="authentication__title">Пароль</span>
    <input class="authentication__input" type="password" name="password" placeholder=" " />
  </label>
  <button class="authentication__btn" type="submit">
    Отправить
  </button>
</form>

<!--3.BEM. Элемент - плоская структура.
Элемент — всегда часть блока, а не другого элемента.
Полезно
Элементы блока могут быть вложены один в другой, но это никак не отражается на названии элемента.

Внимание
В методологии БЭМ "элемент элемента" - это грубая ошибка в названии.

Пример:

<!--  Карточка ->
<div class="card">
  <a class="card__link" href="#">
    <div class="card__img-wrapper">  
      <img class="card__image" src="" alt="">
    </div>
    <h4 class="card__title">...</h4>
    <p class="card__description">...</p>
  </a>
</div>
В css такую структуру классов называют плоской, вот ее пример:

.card {}
.card__link {}
.card__img-wrapper {}
.card__img
.card__title
.card__description
Внимание
Грубая ошибка - неверно заданные имена элементов. Это когда имена не плоские, т.е. указывают на вложенность элемента в элемент.

Пример, как не надо делать:

<!--  Карточка ->
<div class="card">
  <a class="card__link" href="#">
    <div class="card__link__img-wrapper">  
      <img class="card__link__img-wrapper__image" src="" alt="">
    </div>
    <h4 class="card__link__title">...</h4>
    <p class="card__link__description">...</p>
  </a>
</div>
Задание
В коде html представлен блок authentication. Элементам этого блока заданы имена классов с ошибкой - классы не плоские (в названии отражена вложенность элемента в элемент). Необходимо сделать названия элементов плоскими, т.е. удалить лишние названия элементов, указывающие на вложенность элемента в элемент.-->

<form class="authentication" autocomplete="off" method="POST" action="javascript:void(0);">
  <label class="authentication__label">
    <span class="authentication__title">Логин</span>
    <input class="authentication__input" type="text" name="login" placeholder=" " />
  </label>
  <label class="authentication__label">
    <span class="authentication__title">Пароль</span>
    <input class="authentication__input" type="password" name="password" placeholder=" " />
  </label>
  <button class="authentication__btn" type="submit">
    Отправить
  </button>
</form>

<!--4.BEM. Модификатор.
Модификатор определяет вид, состояние или поведение блока (или элемента).
Название модификатора отделяется от имени блока или элемента двойным дефисом: имя-блока__имя-элемента--модификтор имя-блока--модификтор

Модификатор отвечает на вопросы о виде: «какой размер?», «какая тема?», «какой цвет?». Например: Размер —-size-s. Тема —-theme-light. Цвет —-color-red;

Модификатор описывает состояние: --active, --disabled, --focused;

Полезно
Класс-модификатор никогда не должен использоваться самостоятельно, а только в паре с тем классом блока или элемента, который он дополняет.

Пример:

<!--  Блок -->
<button class="btn">Да</button>

<!--  Блок и модификатор вида -->
<button class="btn btn--green">Да</button>

<!--  Блок и модификатор состояния -->
<button class="btn btn--hover">Да</button>
Внимание
Грубая ошибка - класс с именем модификатора без исходного имени класса.

Пример как не надо делать:

<!--  Карточка -->
<!--  Блок -->
<button class="btn">Да</button>

<!--  Только одификатор вида -->
<button class="btn--green">Да</button>

<!--  Только модификатор состояния -->
<button class="btn--hover">Да</button>
Задание
В коде html представлен блок authentication. Блоку и элементу этого блока кнопке заданы имена классов с ошибкой - классы содержат только модификаторы. Необходимо исправить названия классов, т.е. добавить названия блока или элемента.-->

<form class="authentication--focused" autocomplete="off" method="POST" action="javascript:void(0);">
  <label class="authentication__label">
    <span class="authentication__title">Логин</span>
    <input class="authentication__input" type="text" name="login" placeholder=" " />
  </label>
  <label class="authentication__label">
    <span class="authentication__title">Пароль</span>
    <input class="authentication__input" type="password" name="password" placeholder=" " />
  </label>
  <button class="authentication__btn--focused" type="submit">
    Отправить
  </button>
</form>

<form class="authentication authentication--focused" autocomplete="off" method="POST" action="javascript:void(0);">
  <label class="authentication__label">
    <span class="authentication__title">Логин</span>
    <input class="authentication__input" type="text" name="login" placeholder=" " />
  </label>
  <label class="authentication__label">
    <span class="authentication__title">Пароль</span>
    <input class="authentication__input" type="password" name="password" placeholder=" " />
  </label>
  <button class="authentication__btn authentication__btn--focused" type="submit">
    Отправить
  </button>
</form>

<!--5.BEM. Микс из блоков.
Миксование (смесь).
Микс (миксование, смесь) - комбинирование на одном теге классов блока и элемента.

Довольно часто блоки находятся внутри других блоков. Это приводит к тому что возникают особенности, которые

относятся к внешнему виду или поведению блока и тогда необходимо использовать модификатор;
относятся к положению
Пример:

<!-  Блок ->
<button class="btn">Да</button>

<!- Блок внутри блока card меняет вид,
     т.е. используем модификатор ->
<div class="card">
    <p>Карточка</p>
    <button class="btn btn--green">Да</button>
    <button class="btn btn--red">Нет</button>
</div>

<!-  Блок внутри блока subscription меняет положение, 
т.е. используем микс  ->
<form class="subscription" action="javascript:void(0);">
    <input class="subscription__input" 
            type="email" 
            name="email" 
            placeholder="Электронная почта"
    >
    <button class="btn btn--focused subscription__btn" type="submit">Подписаться</button>
</form>
класс btn будет описывать все базовые стили;
классы btn--green и btn--red будут описывать модификатор вида;
класс btn--focused будет описывать модификатор поведения;
класс subscription__btn будет описывать положение блока btn внутри родительского блока subscription.
Да
Карточка
Да Нет
Электронная почта
 Подписаться
Задание
В коде html представлен блок authentication и блок btn. Добавь блоку btn два класса:

класс с модификатором focused;
класс - микс, который описывает положение элемента внутри родительского класса authentication.-->

<form class="authentication" autocomplete="off" method="POST" action="javascript:void(0);">
  <label class="authentication__label">
    <span class="authentication__title">Логин</span>
    <input class="authentication__input" type="text" name="login" placeholder=" " />
  </label>
  <label class="authentication__label">
    <span class="authentication__title">Пароль</span>
    <input class="authentication__input" type="password" name="password" placeholder=" " />
  </label>
  <button class="btn btn--focused authentication__btn" type="submit">
    Отправить
  </button>
</form>

Block 14. SCSS
<!--1.Переменные. Глобальная область видимости.

Полезно
Только после нажатия на кнопку "Проверить", код в синтаксисе SCSS находящийся в редакторе styles.css будет скомпилирован в обыкновенный CSS и применится к коду в редакторе index.html.

SASS и SCSS - в чем разница? Исторически SCSS — "диалект" языка SASS. Но SASS не поддерживается разработчиками, в отличие от SCSS. Поэтому иногда возникает путаница в терминах - говорят о SASS, а подразумевают именно SCSS, как его разновидность. И хотя это похожие языки, у SASS более лаконичный стиль (например нет точек с запятой) и по этой причине он не совместим с css. В то время как внутри SCSS можно всталять нативный код css без каких-либо проблем.

Далее в описании и задачах везде подразумевается только синтаксис SCSS.

Синтаксис объявления переменной - знак $ перед именем, затем идет имя переменной, двоеточие, значение и точка с запятой.

Синтаксис вызова переменной в SCSS - знак $ перед именем, затем идет имя переменной вместо значения. И точка с запятой в конце.

Пример объявления в глобальной области видимости и использования переменной с именем main-color и значения #fff :

$main-color: #fff;
a {
  color: $main-color;
}
Скомпилированный код:

a {
  color:  #fff;
}
Задание
Замени все цвета в свойствах background-color, color и border на SCSS переменные в глобальной области видимости. Для этого:

Под строкой с комментарием /* palette */ напиши три переменные scss c именами blue, lightBlue и white.
Задай этим переменным значения:
для blue значение цвета #6610f2;
для lightBlue значение цвета #007bff;
для white значение цвета #fff.
Для css свойств background-color, color и border замени значения цвета на имена переменных.-->
<button type="button" class="btn">Ok</button>
/* palette */
$blue:#6610f2;
$lightBlue:#007bff;
$white:#fff;

.btn {
padding: .25rem 1.75rem;
color: $white;
background-color: $lightBlue;
border: $blue;
cursor: pointer;
}

.btn:hover,
.btn:focus {
background-color: $blue;
}


<!--2.SCSS
Переменные. Локальная область видимости.

Полезно
Только после нажатия на кнопку "Проверить", код в синтаксисе SCSS находящийся в редакторе styles.css будет скомпилирован в обыкновенный CSS и применится к коду в редакторе index.html.

Если переменную SCSS задать внутри селектора, то такая переменная будет доступна только для этого селектора. Это называется 'переменная находится в локальной области видимости'.

Пример объявления в локальной области видимости и использования переменной с именем main-color и значения #fff :

a {
  $main-color: #fff;
  color: $main-color;
}
Скомпилированный код:

a {
  color:  #fff;
}
Внимание
Если переменную объявить ПОСЛЕ ее использования, то такой код не скомпилируется.

Так делать нельзя:

a {
  color: $main-color;
  $main-color: #fff;
}
Задание
Задай локальную переменную с именем diameter в локальной области видимости селектора .up. Задай значение для переменной с именем diameter такое, как у свойства width и height этого селектора.

Замени значение свойств width и height селектора .up на переменную с именем diameter.-->
<a href="#up" class="up">Вверх</a>

/* palette */
$blue: #6610f2;
$lightBlue: #007bff;
$white: #fff;
$diameter:80px;

.up {
display: flex;
justify-content: center;
align-items: center;
color: $white;
background-color: $lightBlue;
border: #6610f2;
cursor: pointer;
border-radius: 50%;
/* Измени код под этой строкой */
width: $diameter;
height: $diameter;
}

.up:hover,
.up:focus {
background-color: $blue;
}

<!--3.SCSS
@extend - использование существующих стилей.

Полезно
Только после нажатия на кнопку "Проверить", код в синтаксисе SCSS находящийся в редакторе styles.css будет скомпилирован в обыкновенный CSS и применится к коду в редакторе index.html.

Директива @extend используется для повторного использования уже существующих стилей.

Пример:

.link {
  text-decoration: none;
  color: currentColor;
}

a {
 @extend .link;
}
Задание
В scss коде задан селектор .circle для описания круга диаметром 80px. С помощью директивы @extend примени правила для создания круга селектору .up.-->

<a href="up" class="up">Вверх</a>

/* palette */
$blue: #6610f2;
$lightBlue: #007bff;
$white: #fff;

.circle {
$diameter: 80px;
width: $diameter;
height: $diameter;
border-radius: 50%;
}

.up {
display: flex;
justify-content: center;
align-items: center;
color: $white;
background-color: $lightBlue;
border: #6610f2;
cursor: pointer;
/* Добавь код под этой строкой */
@extend .circle;
}

.up:hover,
.up:focus {
background-color: $blue;
}

<!--4.SCSS
Плейсхолдер.

Полезно
Только после нажатия на кнопку "Проверить", код в синтаксисе SCSS находящийся в редакторе styles.css будет скомпилирован в обыкновенный CSS и применится к коду в редакторе index.html.

Плейсхолдер (placeholder) - произвольное имя селектора с обязательным символом % в начале.

Вызов плейсхолдера происходит с помощью директивы @extend внутри селектора.

Пример объявления плейсхолдера и последуещего вызова:

%link {
  text-decoration: none;
  color: currentColor;
}

a {
 @extend %link;
}
Задание
В scss коде задан селектор .circle для описания круга диаметром 80px. Замени селектор на плейсхолдер с названием circle. С помощью директивы @extend и плейсхолдера примени правила для создания круга селектору .up.-->

<a href="up" class="up">Вверх</a>

/* palette */
$blue: #6610f2;
$lightBlue: #007bff;
$white: #fff;

/* Измени код под этой строкой */
%circle {
$diameter: 80px;
width: $diameter;
height: $diameter;
border-radius: 50%;
}

.up {
display: flex;
justify-content: center;
align-items: center;
color: $white;
background-color: $lightBlue;
border: #6610f2;
cursor: pointer;
/* Добавь код под этой строкой */
@extend %circle;
}

.up:hover,
.up:focus {
background-color: $blue;
}


<!--5.SCSS
Миксин.

Полезно
Только после нажатия на кнопку "Проверить", код в синтаксисе SCSS находящийся в редакторе styles.css будет скомпилирован в обыкновенный CSS и применится к коду в редакторе index.html.

Директива @mixin, как и плейсхолдеры, позволяет создавать готовые наборы свойств, но с различными значениями, в зависимости от полученных аргументов при вызове миксина.

Синтаксис состоит из объявления директивы @mixin, затем название миксина, затем круглые скобки с параметрами -
переменной scss (или переменными через запятую). Далее идет описание css правил внутри фигурных скобок, где в качестве значения может выступать переменная из круглых скобок (параметр).

Пример как с помощью миксина задать два квадрата шириной и высотой 100px для селектора .box и шириной и высотой 200px для селектора big-box:

@mixin square ($line) {
  width: $line;
  height: $line;
} 

.box {
  @include square(100px);
}
.big-box {
  @include square(200px);
}
Скомпилированный код:

.box {
  width: 100px;
  height: 100px;
}
.big-box {
  width: 200px;
  height: 200px;
}
Задание
Задан плейсхолдер %circle с размером в 80px. Замени плейсхолдер %circle на миксин circle, который сможет получать любые размеры диаметра.

Вызови миксин circle в селекторе .up со значением 100px;-->
<a href="up" class="up">Вверх</a>
/* palette */
$blue: #6610f2;
$lightBlue: #007bff;
$white: #fff;

/* Измени код под этой строкой */
@mixin circle($diameter){
$diameter: 100px;
width: $diameter;
height: $diameter;
border-radius: 50%;
}

.up {
display: flex;
justify-content: center;
align-items: center;
color: $white;
background-color: $lightBlue;
border: #6610f2;
cursor: pointer;
/* Измени код под этой строкой */
@include circle(100px);
}

.up:hover,
.up:focus {
background-color: $blue;
}

<!--6.SCSS
Вложенность селекторов.

Полезно
Только после нажатия на кнопку "Проверить", код в синтаксисе SCSS находящийся в редакторе styles.css будет скомпилирован в обыкновенный CSS и применится к коду в редакторе index.html.

В SCSS можно вкладывать одно правило в другое, что при компиляции приведет к отношению селекторов родитель и потомок на любом уровне вложенности.

Пример:

<section>
  <div class="first">
    <h4>Заголовок</h4>
    <div> Непрямой потомок section</div>
  </div>
  <div class="first">1</div>
</section>
section {
  div { }
  h4 { }
}
Скомпилированный код:

section  div {}
section  h4 {}
Задание
В редакторе css дан код. Перепиши этот код используя синтаксис scss для вложенности селекторов.

Для этого:

размести селектор label без правил и внутри него размести селектор span с правилом { color: #888; };
размести селектор label:focus-within  без правил и внутри него размести селектор span с правилом { green: #888; } .-->
<label>
  <span>Имя</span>
  <input type="text" name="name" placeholder="Имя" />
</label>
label {
span {color: #888;}
}

label:focus-within {
span {
color: green;}
}

<!--7.SCSS
Конкатенация селекторов с помощью оператора &.

Полезно
Только после нажатия на кнопку "Проверить", код в синтаксисе SCSS находящийся в редакторе styles.css будет скомпилирован в обыкновенный CSS и применится к коду в редакторе index.html.

Селектор элемента и пcевдоэлемента (псевдокласса) должны быть одной строкой. Для реализации такой возможности в scss с помощью синтаксиса вложения используют оператор &.

Пример:

a {
  color: blue;
  &:hover {
    color: blue;
  }
}
Скомпилированный код:

a {
  color: blue;
}
a:hover {
  color: blue;
}
Задание
В редакторе css дан код scss. Используй & для конкатенации label и псевдокласса :focus-within. Перепиши код так, чтобы получить вложенность селектора span внутри селектора label согласно возможностям синтаксиса scss. Селектор label должен быть записан только один раз.

В редакторе css дан код. Перепиши этот код используя синтаксис scss для вложенности и склейки селекторов.

Для этого размести селектор label без правил и внутри него размести:

селектор span с правилом { color: #888; };
селектор &:focus-within  без правил и внутри него размести селектор span с правилом { green: #888; }.-->

<label>
  <span>Имя</span>
  <input type="text" name="name" placeholder="Имя" />
</label>
label {
span {color: #888;};
&:focus-within {
span {color: green;}

}

}

<!--8.8. SCSS
Карты (словари).

Полезно
Только после нажатия на кнопку "Проверить", код в синтаксисе SCSS находящийся в редакторе styles.css будет скомпилирован в обыкновенный CSS и применится к коду в редакторе index.html.

Синтаксис задания карты - объявление переменной SCSS со значением - круглыми кавычками и парами ключ - значение внутри круглых кавычек. Пары ключ-значение разделяются двоеточием и заканчиваются запятой (включая последнюю пару). Ключ (то что слева от двоеточия) - находится в одинарных кавычках. Пример:

$weekdays: (
  'primary': grey,
  'accent': slategray,
);
Вызов значения осуществляется с помощью встроенной SASS-функции map-get(имя_карты, имя_свойства). Пример:

$weekdays: (
  'primary': grey,
  'accent': slategray,
);

p {
color: map-get($weekdays, 'primary');
}
Карты удобны для создания тема сайта. В коде ниже рассмотрен пример как с помощью карт создаются наборы тем для обычного и праздничного оформления сайта. Замену значений переменных с помощью map сделать довольно легко, при этом основной код не изменяется.

// карта для обычной темы
$weekdays: (
  'primary': grey,
  'accent': slategray,
);

// карта для праздничной темы
$holidays: (
  'primary': orange,
  'accent': red,
);

// Применяем обычную тему: $weekdays
$main: map-get($weekdays, 'primary');
$link: map-get($weekdays, 'accent');

// Применяем праздничную тему:: $holidays
// $main: map-get($holidays, 'primary');
// $link: map-get($holidays, 'accent');

p {
 color: $main;
}

a {
  color: $link;
}
Скомпилированный код:

p {
  color: grey;
}
a {
  color: slategray;
}

Задание
Для содержимого редактора html написан код scss с картой цвета. C помощью встроенной SASS-функции map-get(имя_карты, имя_свойства) задай цвет текста элемента label согласно тексту атрибута for , т.е. для id-red необходимо из карты $rgb задать значение свойства red, для id-green - значение green и т.д.-->

<form action="javascript:void(0);" id="id-radio">
  <div>
    <label for="id-red">red</label>
    <label for="id-green">green</label>
    <label for="id-blue">blue</label>
  </div>
  <div>
    <input id="id-red" name="colors" type="radio" value="red" />
    <input id="id-green" name="colors" type="radio" value="green" />
    <input id="id-blue" name="colors" type="radio" value="blue" />
  </div>
</form>

<button form="id-radio" type="submit">Отправить</button>
<button form="id-radio" type="reset">Обновить</button>

body {
text-align: center;
}

$rgb: (
'red': #f00,
'green': #080,
'blue': #00f,
);

label[for="id-red"] {
color: map-get($rgb, 'red')
}

label[for="id-green"] {
color: map-get($rgb, 'green')
}

label[for="id-blue"] {
color: map-get($rgb, 'blue')
}

<!--9.SCSS
Математические операции.

Полезно
Только после нажатия на кнопку "Проверить", код в синтаксисе SCSS находящийся в редакторе styles.css будет скомпилирован в обыкновенный CSS и применится к коду в редакторе index.html.

поддержка стандартных операций: +, -, *, / и % (остаток от деления по модулю);
нельзя смешивать типы единиц;
нельзя использовать нативные css переменные;
можно использовать нативную функцию calc().
Пример:

$gap : 8px;

p {
  text-indent: 3 * $gap;
  padding-top: $gap + 2px;
  padding-bottom: $gap - 2px;
  padding-right: $gap / 2;
  padding-left: $gap % 3;
}
Пример использования математических операций для создания с помощью миксина кнопок с пропорциональными размерами отступов, относительно размера шрифта.

<button class="small-btn">ok</button>
<button class="middle-btn">ok</button>
<button class="big-btn">ok</button>
@mixin button($size) {
  padding: .25 * $size  1.75 * $size;
  font-size: $size;
}
button {
  text-transform: uppercase;
}
.small-btn {
  @include button(16px);
}
.middle-btn {
  @include button(20px);
}
.big-btn {
  @include button(28px);
}
Скомпилированный код:

button {
  text-transform: uppercase;
}

.small-btn {
  padding: 4px 28px;
  font-size: 16px;
}

.middle-btn {
  padding: 5px 35px;
  font-size: 20px;
}

.big-btn {
  padding: 7px 49px;
  font-size: 28px;
}
OK OK OK
Задание
Для миксина center задай значения свойствам margin-top и margin-left с помощью оператора деления (делить на -2) так, чтобы прямоугольник элемента с классом box оказался ровно по центру родительского блока.

PS Деление на -2 заменит деление на 2 и затем умножение на -1.

Используй переменные $width и $height.-->
<div class="box"></div>
@mixin center ($width, $height) {
position: absolute;
width: $width;
height: $height;
top: 50%;
left: 50%;
margin-top: $height / -2;
margin-left: $width / -2
}

.box {
background: gold;
@include center(100px, 50px);
}

<!--10.SCSS
Фрагментирование и импорт.

Полезно
Только после нажатия на кнопку "Проверить", код в синтаксисе SCSS находящийся в редакторе styles.css будет скомпилирован в обыкновенный CSS и применится к коду в редакторе index.html.

Фрагмент — это простой SCSS-файл, который компилируется не в отдельный CSS файл, а является частью (фрагментом) какого-то CSS файла или файлов.

Синтаксис фрагмента - нижнее подчеркивание перед именем файла (по этому признаку компилятор понимает что создавать CSS файл из этого SCSS файла не надо).

Пример названия файлов-фрагмента:

_normalize.scss
_button.scss
Для включения фрагментов в один общий файл в SCSS существует директива @import. При ее использовании необходимо указать путь к файлу и название файла без подчеркивания и даже без расширения SCSS

Пример:

@import 'normalize';
@import 'button';
В скомпилированном коде CSS правила обоих файлов объединятся в один общий файл так, что порядок импорта файлов совпадет с порядком CSS правил. Иначе говоря нормализацию стилей, фрагмент с SCSS переменными следует импортировать в первую очередь.

Задание
Дан список файлов SCSS:

_normalizer.scss
_variables.scss
_header.scss
about.scss
contacts.scss
Напиши список импорта всех фрагментов (но не файлов!) в правильном порядке.
Для импорта используй название фрагментов без указания расширения файла и подчеркивания.-->
<!--
_normalizer.scss
_variables.scss
_header.scss
about.scss
styles.scss
-->
@import 'normalizer';
@import 'variables';
@import 'header';



Block 15.
<!--1.-->
<!--2.-->
<!--3.-->
<!--4.-->
<!--5.-->
<!--6.-->
<!--7.-->


Block 16.
<!--1.-->
<!--2.-->
<!--3.-->
<!--4.-->
<!--5.-->
<!--6.-->
<!--7.-->